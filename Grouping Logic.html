// ... inside window.addEventListener('keydown', (e) => { ...

else if (e.shiftKey && e.key.toLowerCase() === 'g') {
    e.preventDefault();
    // Find all selected objects that are at the top level of the scene hierarchy
    const selectedTopLevelObjects = state.levelObjects.filter(obj => state.selectedObjects.has(obj.id));

    // Grouping makes sense only if there are 2 or more objects selected at the same level
    if (selectedTopLevelObjects.length > 1) {
        saveStateForUndo(); // Save the state before making changes

        // Calculate the bounding box of all selected objects to determine the new group's position
        const bounds = getSelectionBounds(selectedTopLevelObjects);
        const newGroup = {
            id: state.nextObjectId++,
            name: "New Group",
            type: 'group',
            x: bounds.minX,
            y: bounds.minY,
            children: []
        };
        
        const idsToRemove = new Set();
        selectedTopLevelObjects.forEach(obj => {
            idsToRemove.add(obj.id);
            // Create a deep copy of the object to place inside the group
            const newChild = deepClone(obj);
            // Recalculate the child's coordinates to be relative to the new group's origin
            newChild.x -= newGroup.x;
            newChild.y -= newGroup.y;
            newGroup.children.push(newChild);
        });

        // Remove the original objects from the main level scene
        state.levelObjects = state.levelObjects.filter(obj => !idsToRemove.has(obj.id));
        
        // Add the newly created group to the scene
        state.levelObjects.push(newGroup);
        
        // Clear the old selection and select only the new group
        state.selectedObjects.clear();
        state.selectedObjects.add(newGroup.id);
        
        // Refresh all UI panels and redraw the canvas
        updateAllPanels();
        draw();
    }
}

// ... other keydown logic
