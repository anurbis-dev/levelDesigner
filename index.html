<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Level Editor</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <!-- Load Tailwind CSS for quick styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Apply user settings immediately to prevent visual jumps -->
    <script>
        // Apply user settings immediately, before any rendering
        (function() {
            try {
                const stored = localStorage.getItem('levelEditor_userConfig_complete');
                if (stored) {
                    const prefs = JSON.parse(stored);
                    const fontScale = prefs.ui?.fontScale || 1.0;
                    const spacingScale = prefs.ui?.spacing || 1.0;
                    
                    if (fontScale !== 1.0) {
                        // Set CSS custom property immediately
                        document.documentElement.style.setProperty('--font-scale', fontScale);
                        document.documentElement.style.fontSize = fontScale * 16 + 'px';
                    }
                    
                    if (spacingScale !== 1.0) {
                        // Set CSS custom property immediately
                        document.documentElement.style.setProperty('--spacing-scale', spacingScale);
                    }
                }
            } catch (error) {
                // Ignore errors during early initialization
            }
        })();
    </script>
    
    <!-- Main styles -->
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/spacing-mode.css">
    <link rel="stylesheet" href="styles/panels.css">
    <link rel="stylesheet" href="styles/layers-panel.css">
    <link rel="stylesheet" href="styles/settings-panel.css">
    <link rel="stylesheet" href="styles/grid-settings.css">
    <link rel="stylesheet" href="styles/details-panel.css">
    <link rel="stylesheet" href="styles/color-chooser.css">
    <link rel="stylesheet" href="styles/base-context-menu.css">
    <link rel="stylesheet" href="styles/canvas-context-menu.css">
    <link rel="stylesheet" href="styles/console-context-menu.css">
    <link rel="stylesheet" href="styles/user-settings.css">
</head>
<body class="bg-gray-800 text-white font-sans flex flex-col h-screen">

    <!-- 1. Main menu on top -->
    <header class="bg-gray-900 shadow-md flex-shrink-0">
        <nav class="flex items-center justify-between">
            <!-- Menu container - will be populated by MenuManager -->
            <div id="menu-container" class="flex items-center">
                <!-- Menus will be dynamically generated here -->
            </div>
            <div class="text-sm text-gray-400">
                <span id="header-version-info">2D Level Editor</span>
            </div>
        </nav>
    </header>

    <!-- Main container with working areas -->
    <div class="flex flex-grow min-h-0">
        <!-- 2. Main Frame (main workspace) -->
        <main id="main-panel" class="flex-1 flex flex-col bg-gray-700 min-w-0">
            <!-- Toolbar in top part of canvas -->
            <div id="toolbar-container" class="bg-gray-800 flex-shrink-0">
                <!-- Toolbar will be populated by Toolbar component -->
            </div>
            
            <!-- Canvas area -->
            <div class="flex-1 min-h-0">
                <canvas id="main-canvas"></canvas>
            </div>
        </main>

        <!-- Separator for changing right panel width -->
        <div id="resizer-x" class="resizer"></div>

        <!-- 4. Details Panel (right) -->
        <aside id="right-panel" class="bg-gray-900 flex flex-col">
            <div class="flex border-b border-gray-700 flex-shrink-0">
                <button data-tab="details" class="tab-right active" id="details-tab">Asset</button>
                <button data-tab="layers" class="tab-right">Layers</button>
                <button data-tab="outliner" class="tab-right">Outliner</button>
            </div>
            <!-- Search section - non-scrollable -->
            <div id="right-panel-search" class="border-b border-gray-700 flex-shrink-0">
                <!-- Search controls will be added here dynamically -->
            </div>
            <div class="flex-grow overflow-y-auto">
                <div id="details-content-panel" class="tab-content-right">
                     <p class="text-gray-400">Select an object to see its properties.</p>
                </div>
                <div id="layers-content-panel" class="tab-content-right hidden">
                     <!-- Layers content here -->
                </div>
                <div id="outliner-content-panel" class="tab-content-right hidden">
                     <!-- Outliner content here -->
                </div>
            </div>
        </aside>
    </div>

        <!-- Separator for changing asset panel height -->
    <div id="resizer-assets" class="resizer-y"></div>

        <!-- 3. Assets Drawer (assets panel) -->
    <footer id="assets-panel" class="h-64 bg-gray-900 flex-shrink-0 flex flex-col relative">
        <div id="asset-tabs-container" class="flex border-b border-gray-700">
            <!-- Tabs will be generated dynamically -->
        </div>
        <div id="asset-previews-container" class="flex-grow overflow-auto p-1">
            <!-- Asset previews container will be generated dynamically -->
        </div>
    </footer>

    <!-- Console Panel as Overlay (hidden by default) -->
    <div id="console-panel" class="console-overlay hidden bg-gray-900 flex flex-col">
        <div class="flex border-b border-gray-700 flex-shrink-0">
            <span class="flex-1 text-sm font-medium text-gray-300">Console</span>
            <button id="console-close" class="text-gray-400 hover:text-white hover:bg-gray-700">&times;</button>
        </div>
        <div class="flex-grow overflow-y-auto">
            <div id="console-output" class="text-gray-300 font-mono text-sm">
                <!-- Console output will be displayed here -->
            </div>
        </div>
        <div class="border-t border-gray-700 flex-shrink-0 flex items-center">
            <span class="text-gray-400 mr-2">&gt;</span>
            <input id="console-input" name="console-input" type="text" placeholder="Enter command..." 
                   class="flex-grow bg-transparent text-gray-300 border-none outline-none font-mono text-sm">
        </div>
        <div class="console-resize-handle"></div>
    </div>

    <!-- Application logic -->
    <script type="module">
        import { LevelEditor } from './src/core/LevelEditor.js';
        import { ConsoleContextMenu } from './src/ui/ConsoleContextMenu.js';
        import { Logger } from './src/utils/Logger.js';
        import { MenuManager } from './src/managers/MenuManager.js';
        import { UserPreferencesManager } from './src/managers/UserPreferencesManager.js';

        // Safe logging function that works even if Logger is not available
        function safeLog(level, message, ...args) {
            try {
                if (typeof Logger !== 'undefined' && Logger.layout && Logger.layout[level]) {
                    Logger.layout[level](message, ...args);
                } else {
                    console[level === 'error' ? 'error' : 'log'](`[LAYOUT] ${message}`, ...args);
                }
            } catch (error) {
                try {
                    console.log(`[LAYOUT] ${message}`, ...args);
                } catch (fallbackError) {
                    // Last resort - just log to console
                    console.log(`[LAYOUT] ${message}`);
                }
            }
        }

        // Apply basic user settings IMMEDIATELY to prevent visual jumps
        // This must happen before any DOM manipulation
        function applyUserSettingsImmediately(userPrefs) {
            try {
                // Font scale is applied early in <head> and live via StateManager

                // Apply theme immediately if available
                const theme = userPrefs.get('theme');
                if (theme && theme !== 'dark') {
                    try {
                        document.body.classList.add(`theme-${theme}`);
                    } catch (themeError) {
                        console.warn('[LAYOUT] Failed to apply theme:', themeError);
                    }
                }

                // Apply compact mode immediately
                const compactMode = userPrefs.get('compactMode');
                if (compactMode) {
                    try {
                        document.body.classList.add('compact-mode');
                    } catch (compactError) {
                        console.warn('[LAYOUT] Failed to apply compact mode:', compactError);
                    }
                }

                // Apply panel visibility settings immediately
                const consoleVisible = userPrefs.get('consoleVisible');
                if (consoleVisible !== undefined) {
                    try {
                        const consolePanel = document.getElementById('console-panel');
                        if (consolePanel) {
                            if (consoleVisible) {
                                consolePanel.classList.remove('hidden');
                            } else {
                                consolePanel.classList.add('hidden');
                            }
                        }
                    } catch (consoleError) {
                        console.warn('[LAYOUT] Failed to apply console visibility:', consoleError);
                    }
                }

                // Apply toolbar visibility immediately
                const toolbarVisible = userPrefs.get('toolbarVisible');
                if (toolbarVisible !== undefined) {
                    try {
                        const toolbarContainer = document.getElementById('toolbar-container');
                        if (toolbarContainer) {
                            if (toolbarVisible) {
                                toolbarContainer.classList.remove('hidden');
                                toolbarContainer.style.display = 'flex';
                            } else {
                                toolbarContainer.classList.add('hidden');
                                toolbarContainer.style.display = 'none';
                            }
                        }
                    } catch (toolbarError) {
                        console.warn('[LAYOUT] Failed to apply toolbar visibility:', toolbarError);
                    }
                }

                // Apply assets panel visibility immediately
                const assetsPanelVisible = userPrefs.get('assetsPanelVisible');
                if (assetsPanelVisible !== undefined) {
                    try {
                        const assetsPanel = document.getElementById('assets-panel');
                        const resizerAssets = document.getElementById('resizer-assets');
                        if (assetsPanel) {
                            if (assetsPanelVisible) {
                                assetsPanel.classList.remove('hidden');
                                assetsPanel.style.display = 'flex';
                                if (resizerAssets) {
                                    resizerAssets.classList.remove('hidden');
                                    resizerAssets.style.display = 'block';
                                }
                            } else {
                                assetsPanel.classList.add('hidden');
                                assetsPanel.style.display = 'none';
                                if (resizerAssets) {
                                    resizerAssets.classList.add('hidden');
                                    resizerAssets.style.display = 'none';
                                }
                            }
                        }
                    } catch (assetsError) {
                        console.warn('[LAYOUT] Failed to apply assets panel visibility:', assetsError);
                    }
                }

                // Apply right panel visibility immediately
                const rightPanelVisible = userPrefs.get('rightPanelVisible');
                if (rightPanelVisible !== undefined) {
                    try {
                        const rightPanel = document.getElementById('right-panel');
                        const resizerX = document.getElementById('resizer-x');
                        if (rightPanel) {
                            if (rightPanelVisible) {
                                rightPanel.classList.remove('hidden');
                                rightPanel.style.display = 'flex';
                                if (resizerX) {
                                    resizerX.classList.remove('hidden');
                                    resizerX.style.display = 'block';
                                }
                            } else {
                                rightPanel.classList.add('hidden');
                                rightPanel.style.display = 'none';
                                if (resizerX) {
                                    resizerX.classList.add('hidden');
                                    resizerX.style.display = 'none';
                                }
                            }
                        }
                    } catch (rightError) {
                        console.warn('[LAYOUT] Failed to apply right panel visibility:', rightError);
                    }
                }

                // Apply panel sizes immediately to prevent UI flicker
                try {
                    // Right panel width
                    const rightPanelWidth = userPrefs.get('rightPanelWidth');
                    if (rightPanelWidth) {
                        const rightPanel = document.getElementById('right-panel');
                        if (rightPanel) {
                            rightPanel.style.width = rightPanelWidth + 'px';
                            rightPanel.style.flexShrink = '0';
                            rightPanel.style.flexGrow = '0';
                        }
                    }

                    // Assets panel height
                    const assetsPanelHeight = userPrefs.get('assetsPanelHeight');
                    if (assetsPanelHeight) {
                        const assetsPanel = document.getElementById('assets-panel');
                        if (assetsPanel) {
                            assetsPanel.style.height = assetsPanelHeight + 'px';
                            assetsPanel.style.flexShrink = '0';
                        }
                    }

                    // Console height
                    const consoleHeight = userPrefs.get('consoleHeight');
                    if (consoleHeight) {
                        const consolePanel = document.getElementById('console-panel');
                        if (consolePanel) {
                            const height = Math.max(200, Math.min(window.innerHeight * 0.9, consoleHeight));
                            consolePanel.style.setProperty('height', height + 'px', 'important');
                            consolePanel.style.setProperty('bottom', 'auto', 'important');
                        }
                    }
                } catch (sizeError) {
                    console.warn('[LAYOUT] Failed to apply panel sizes:', sizeError);
                }

            } catch (error) {
                console.warn('[LAYOUT] Failed to apply user settings immediately:', error);
            }
        }

        // User Preferences Manager - Initialize BEFORE LevelEditor

        // Initialize preferences manager FIRST
        let userPrefs;
        try {
            userPrefs = new UserPreferencesManager();
        } catch (error) {
            console.error('Error creating UserPreferencesManager:', error);
            // Create a fallback preferences manager
            userPrefs = {
                get: () => undefined,
                set: () => {},
                update: () => {}
            };
        }

        // Apply ALL user settings immediately BEFORE LevelEditor initialization
        try {
            applyUserSettingsImmediately(userPrefs);
        } catch (error) {
            console.error('Error applying user settings immediately:', error);
        }

        // Initialize the level editor with user preferences
        let editor;
        try {
            editor = new LevelEditor(userPrefs);
        } catch (error) {
            console.error('Error creating LevelEditor:', error);
            // Create a fallback editor
            editor = {
                init: () => Promise.resolve(),
                render: () => {},
                canvasRenderer: { resizeCanvas: () => {} }
            };
        }

        // Initialize the editor
        try {
            editor.init().then(() => {
                // Panel sizes are now applied immediately before LevelEditor initialization to prevent UI flicker
                console.log('Level Editor initialized successfully');
            }).catch(error => {
                console.error('Failed to initialize level editor:', error);
                console.error('Error details:', error);
                // Don't show alert for async response errors from extensions
                if (!error.message || !error.message.includes('message channel closed')) {
                    try {
                        alert('Failed to initialize level editor: ' + (error.message || error));
                    } catch (alertError) {
                        console.error('Failed to show alert:', alertError);
                    }
                }
            });
        } catch (error) {
            console.error('Error calling editor.init():', error);
        }

        // User preferences manager is already initialized above

        // Console height is now applied immediately in applyUserSettingsImmediately() to prevent UI flicker

        // Panel sizes are now applied immediately before LevelEditor initialization to prevent UI flicker
            
            // Function to force complete layout update
            function forceLayoutUpdate() {
                try {
                    // Get main elements
                    const mainContainer = document.querySelector('.flex.flex-grow.min-h-0');
                    const mainPanel = document.getElementById('main-panel');
                    const rightPanel = document.getElementById('right-panel');
                    const assetsPanel = document.getElementById('assets-panel');
                    const consolePanel = document.getElementById('console-panel');

                // Only reset console styles when hidden - preserve other panel sizes
                // Don't reset height as it's managed by user preferences
                if (consolePanel.classList.contains('hidden')) {
                    consolePanel.style.flexShrink = '';
                    consolePanel.style.display = '';
                    // Height is preserved and restored from user preferences when shown
                }

                // Minimal reflow trigger - only for main container to avoid affecting panel positions
                if (mainContainer) {
                    // Use getComputedStyle instead of offsetHeight to avoid layout changes
                    const computedStyle = getComputedStyle(mainContainer);
                    // This triggers a minimal reflow without changing layout
                    const _ = computedStyle.height;
                }

                // Update canvas and render immediately
                if (window.editor && window.editor.canvasRenderer) {
                    window.editor.canvasRenderer.resizeCanvas();
                    window.editor.render();
                }
                } catch (error) {
                    console.error('Error in forceLayoutUpdate:', error);
                }
            }
            
            // Function to update canvas layout (called when panels show/hide)
            function updateCanvasLayout() {
                try {
                    // Only update canvas without forcing full layout to avoid panel drift
                    if (window.editor && window.editor.canvasRenderer) {
                        window.editor.canvasRenderer.resizeCanvas();
                        window.editor.render();
                    }
                } catch (error) {
                    console.error('Error in updateCanvasLayout:', error);
                }
            }

        // Panel resizing functionality
        function setupPanelResizing() {
            try {
                const resizerX = document.getElementById('resizer-x');
                const resizerAssets = document.getElementById('resizer-assets');
                const mainPanel = document.getElementById('main-panel');
                const rightPanel = document.getElementById('right-panel');
                const assetsPanel = document.getElementById('assets-panel');
                const consolePanel = document.getElementById('console-panel');
                const mainContainer = document.querySelector('.flex.flex-grow.min-h-0');

            let isResizingX = false;
            let isResizingAssets = false;
            let isAnyResizing = false;
            
            // Variables to track initial positions for resizing
            let initialMouseY = 0;
            let initialMouseX = 0;
            let initialAssetsPanelHeight = 0;
            let initialRightPanelWidth = 0;
            let lastAppliedRightWidth = null; // Track last width to detect boundary stall

            // Note: Panel sizes are now applied immediately before LevelEditor initialization to prevent UI flicker

            // Horizontal resizer (between main panel and right panel)
            resizerX.addEventListener('mousedown', (e) => {
                isResizingX = true;
                isAnyResizing = true;
                initialMouseX = e.clientX;
                initialRightPanelWidth = rightPanel.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                document.body.style.pointerEvents = 'none';
                resizerX.classList.add('resizing');
                e.preventDefault();
                e.stopPropagation();
            });

            // Assets panel resizer (between main area and assets panel)
            resizerAssets.addEventListener('mousedown', (e) => {
                isResizingAssets = true;
                isAnyResizing = true;
                initialMouseY = e.clientY;
                initialAssetsPanelHeight = assetsPanel.offsetHeight;
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                document.body.style.pointerEvents = 'none';
                resizerAssets.classList.add('resizing');
                
                e.preventDefault();
                e.stopPropagation();
            });


            // Mouse move handler
            document.addEventListener('mousemove', (e) => {
                if (!isAnyResizing) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                if (isResizingX) {
                    // Use same logic as assets resizer: mouse movement from initial position
                    const mouseDelta = e.clientX - initialMouseX;
                    const containerWidth = mainContainer.clientWidth;
                    const resizerWidth = 6;
                    // Right panel can range from 0 to (containerWidth - resizerWidth)
                    let newWidth = initialRightPanelWidth - mouseDelta;
                    if (newWidth < 0) newWidth = 0;
                    const maxWidth = Math.max(0, containerWidth - resizerWidth);
                    if (newWidth > maxWidth) newWidth = maxWidth;

                    // If width didn't change compared to last applied (stuck at boundary), skip work
                    if (lastAppliedRightWidth !== null && newWidth === lastAppliedRightWidth) {
                        return;
                    }
                    
                    // Apply directly
                    rightPanel.style.width = newWidth + 'px';
                    rightPanel.style.flexShrink = '0';
                    rightPanel.style.flexGrow = '0';

                    lastAppliedRightWidth = newWidth;

                    // Save preference
                    userPrefs.set('rightPanelWidth', newWidth);

                    // Update canvas
                    if (window.editor && window.editor.canvasRenderer) {
                        window.editor.canvasRenderer.resizeCanvas();
                        window.editor.render();
                    }
                }
                
                if (isResizingAssets) {
                    // Calculate height based on mouse movement from initial position
                    const mouseDelta = e.clientY - initialMouseY;
                    const newHeight = initialAssetsPanelHeight - mouseDelta; // Inverted direction
                    
                    
                    // Apply directly without any limits
                    assetsPanel.style.height = newHeight + 'px';
                    assetsPanel.style.flexShrink = '0';

                    // Save preference
                    userPrefs.set('assetsPanelHeight', newHeight);

                    // Update canvas and render
                    if (window.editor && window.editor.canvasRenderer) {
                        window.editor.canvasRenderer.resizeCanvas();
                        window.editor.render();
                    }
                }
                
            });

            // Mouse up handler
            document.addEventListener('mouseup', (e) => {
                if (isAnyResizing) {
                    isResizingX = false;
                    isResizingAssets = false;
                    isAnyResizing = false;
                    lastAppliedRightWidth = null;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    document.body.style.pointerEvents = '';
                    resizerX.classList.remove('resizing');
                    resizerAssets.classList.remove('resizing');
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent text selection during resize
            document.addEventListener('selectstart', (e) => {
                if (isAnyResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent context menu during resize
            document.addEventListener('contextmenu', (e) => {
                if (isAnyResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent drag during resize
            document.addEventListener('dragstart', (e) => {
                if (isAnyResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent focus changes during resize
            document.addEventListener('focusin', (e) => {
                if (isAnyResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Handle window resize to maintain panel proportions
            window.addEventListener('resize', () => {
                // Get saved panel sizes
                const savedRightPanelWidth = userPrefs.get('rightPanelWidth');
                const savedAssetsPanelHeight = userPrefs.get('assetsPanelHeight');
                const savedConsoleHeight = userPrefs.get('consoleHeight');

                // Restore right panel width (simple like assets panel)
                if (savedRightPanelWidth) {
                    rightPanel.style.width = savedRightPanelWidth + 'px';
                    rightPanel.style.flexShrink = '0';
                    rightPanel.style.flexGrow = '0';
                }

                // Restore assets panel height if saved
                if (savedAssetsPanelHeight) {
                    assetsPanel.style.height = savedAssetsPanelHeight + 'px';
                    assetsPanel.style.flexShrink = '0';
                }

                // Update canvas only (don't call full layout update to avoid drift)
                if (window.editor && window.editor.canvasRenderer) {
                    window.editor.canvasRenderer.resizeCanvas();
                    window.editor.render();
                }
            });
            } catch (error) {
                console.error('Error setting up panel resizing:', error);
            }
        }

        // Initialize panel resizing
        try {
            setupPanelResizing();
        } catch (error) {
            console.error('Error initializing panel resizing:', error);
        }

        // Tab dragging functionality
        function setupTabDragging() {
            try {
                const tabContainer = document.querySelector('#right-panel .flex.border-b.border-gray-700');
                if (!tabContainer) return;

                let draggedTab = null;
                let draggedIndex = -1;

            // Make tabs draggable
            tabContainer.addEventListener('mousedown', (e) => {
                const tab = e.target.closest('.tab-right');
                if (!tab) return;

                draggedTab = tab;
                draggedIndex = Array.from(tabContainer.children).indexOf(tab);
                
                // Add dragging class
                tab.classList.add('dragging');
                
                // Prevent default to avoid text selection
                e.preventDefault();
            });

            // Handle mouse move for drag over effects
            tabContainer.addEventListener('mousemove', (e) => {
                if (!draggedTab) return;

                const tab = e.target.closest('.tab-right');
                if (!tab || tab === draggedTab) {
                    // Remove drag-over from all tabs
                    tabContainer.querySelectorAll('.tab-right').forEach(t => t.classList.remove('tab-drag-over'));
                    return;
                }

                const targetIndex = Array.from(tabContainer.children).indexOf(tab);
                
                // Remove drag-over from all tabs
                tabContainer.querySelectorAll('.tab-right').forEach(t => t.classList.remove('tab-drag-over'));
                
                // Add drag-over to target tab
                tab.classList.add('tab-drag-over');
            });

            // Handle mouse up to complete drag
            document.addEventListener('mouseup', (e) => {
                if (!draggedTab) return;

                const tabContainer = draggedTab.parentElement;
                const targetTab = e.target.closest('.tab-right');
                
                if (targetTab && targetTab !== draggedTab) {
                    const targetIndex = Array.from(tabContainer.children).indexOf(targetTab);
                    const draggedIndex = Array.from(tabContainer.children).indexOf(draggedTab);
                    
                    // Move the tab
                    if (draggedIndex < targetIndex) {
                        tabContainer.insertBefore(draggedTab, targetTab.nextSibling);
                    } else {
                        tabContainer.insertBefore(draggedTab, targetTab);
                    }
                }

                // Clean up
                tabContainer.querySelectorAll('.tab-right').forEach(t => {
                    t.classList.remove('dragging', 'tab-drag-over');
                });
                
                draggedTab = null;
                draggedIndex = -1;
            });

            // Prevent text selection during drag
            tabContainer.addEventListener('selectstart', (e) => {
                if (draggedTab) {
                    e.preventDefault();
                }
            });
            } catch (error) {
                console.error('Error setting up tab dragging:', error);
            }
        }

        // Initialize tab dragging
        try {
            setupTabDragging();
        } catch (error) {
            console.error('Error initializing tab dragging:', error);
        }

        // Console functionality
        let isConsoleVisible = false; // Global variable for console visibility state
        let isLoggingToConsole = false; // Global variable to prevent infinite recursion in console logging
        
        function setupConsole() {
            try {
                const consolePanel = document.getElementById('console-panel');
                const consoleOutput = document.getElementById('console-output');
                const consoleInput = document.getElementById('console-input');
                const consoleClose = document.getElementById('console-close');
                // Get the scrollable container (parent of console-output)
                const consoleScrollContainer = consoleOutput.parentElement;
                let isLoggingEnabled = true;
                
                // Global auto-scroll state (moved here to be accessible by all console functions)
                let isAutoScrollEnabled = true;

            // Function to toggle auto-scroll
            function toggleAutoScroll() {
                isAutoScrollEnabled = !isAutoScrollEnabled;
                logToConsole(`Auto-scroll ${isAutoScrollEnabled ? 'enabled' : 'disabled'}`, 'info');
                
                // If enabling auto-scroll, scroll to bottom immediately
                if (isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            console.warn('Error scrolling console output:', error);
                        }
                    });
                }
            }

            // Function to force scroll to bottom (used when enabling auto-scroll)
            function scrollToBottom() {
                if (isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            console.warn('Error scrolling console output:', error);
                        }
                    });
                }
            }

            // Make toggleAutoScroll globally accessible for console commands
            window.toggleAutoScroll = toggleAutoScroll;

            // Initialize console context menu
            const consoleContextMenu = new ConsoleContextMenu(consolePanel, consoleOutput, {
                onLoggingToggle: (enabled) => {
                    // Update both local and context menu state
                    isLoggingEnabled = enabled;
                    logToConsole(`Logging ${enabled ? 'enabled' : 'disabled'}`, 'info');
                },
                onAutoScrollToggle: () => {
                    toggleAutoScroll();
                },
                onConsoleClear: () => {
                    logToConsole('Console cleared', 'info');
                },
                onCopyToClipboard: (text) => {
                    logToConsole(`Copied to clipboard: ${text}`, 'info');
                }
            });

            // Setup scroll listener to detect manual scrolling
            let scrollTimeout = null;
            consoleScrollContainer.addEventListener('scroll', () => {
                // Clear existing timeout
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                
                // Set a timeout to detect if user scrolled manually
                scrollTimeout = setTimeout(() => {
                    const isAtBottom = Math.abs(consoleScrollContainer.scrollTop - (consoleScrollContainer.scrollHeight - consoleScrollContainer.clientHeight)) < 5;
                    
                    // If user scrolled up manually and auto-scroll was enabled, disable it
                    if (!isAtBottom && isAutoScrollEnabled) {
                        isAutoScrollEnabled = false;
                        logToConsole('Auto-scroll disabled (user scrolled up)', 'info');
                    }
                }, 150); // Small delay to distinguish between manual and automatic scrolling
            });
            
            // Setup selection for existing console messages
            setupExistingConsoleMessages();
            
            // Global selection change handler for all console messages (throttled)
            let selectionTimeout = null;
            document.addEventListener('selectionchange', () => {
                if (selectionTimeout) {
                    clearTimeout(selectionTimeout);
                }
                selectionTimeout = setTimeout(() => {
                    updateAllConsoleSelections();
                }, 50); // Throttle to 50ms
            });

            // Register console context menu with the manager after editor is initialized
            // This will be done after the editor initialization completes

            // Toggle console with backtick key
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    toggleConsole();
                }
            });

            // Close console button
            consoleClose.addEventListener('click', () => {
                hideConsole();
            });

            // Context menu is now handled by ConsoleContextMenu class

            // Console input handling
            consoleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const command = consoleInput.value.trim();
                    if (command) {
                        executeCommand(command);
                        consoleInput.value = '';
                    }
                } else if (e.key === 'Escape') {
                    hideConsole();
                }
            });

            // Console resize functionality
            setupConsoleResizing();

            function setupConsoleResizing() {
                const resizeHandle = consolePanel.querySelector('.console-resize-handle');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = consolePanel.offsetHeight;
                    document.body.style.cursor = 'row-resize';
                    document.body.style.userSelect = 'none';
                    resizeHandle.classList.add('resizing');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
if (!isResizing) return;

                    const deltaY = e.clientY - startY;
                    const newHeight = startHeight + deltaY;
                    const minHeight = 200;
                    const maxHeight = window.innerHeight * 0.9;

                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        consolePanel.style.height = newHeight + 'px';
                        consolePanel.style.bottom = 'auto';
                        
                        // Don't save during resize - only save on mouseup
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        resizeHandle.classList.remove('resizing');
                        
                        // Save the final height when resize is complete
                        const finalHeight = consolePanel.offsetHeight;
                        userPrefs.set('consoleHeight', finalHeight);
                    }
                });
            }

            function toggleConsole() {
                if (isConsoleVisible) {
                    hideConsole();
                } else {
                    showConsole();
                }
            }

            function showConsole() {
                const showConsolePanel = consolePanel; // Use the consolePanel from outer scope

                // Ensure correct height before showing
                const savedConsoleHeight = userPrefs.get('consoleHeight');
                if (savedConsoleHeight && savedConsoleHeight > 0) {
                    const correctHeight = Math.max(200, Math.min(window.innerHeight * 0.9, savedConsoleHeight));
                    showConsolePanel.style.setProperty('height', correctHeight + 'px', 'important');
                }

                showConsolePanel.classList.remove('hidden');
                consoleInput.focus();
                isConsoleVisible = true;

                // Save preference
                userPrefs.set('consoleVisible', true);

                // Scroll to bottom when console is opened
                if (isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            console.warn('Error scrolling console output on show:', error);
                        }
                    });
                }
                
                // Console is now an overlay, no need to update canvas layout
                // The overlay covers everything and doesn't affect the main layout
            }

            function hideConsole() {
                consolePanel.classList.add('hidden');
                isConsoleVisible = false;
                
                // Force hide context menu when console is closed
                if (consoleContextMenu && typeof consoleContextMenu.forceHideMenu === 'function') {
                    consoleContextMenu.forceHideMenu();
                }
                
                // Save preference
                userPrefs.set('consoleVisible', false);
                
                // Console is now an overlay, no need to update canvas layout
                // The overlay covers everything and doesn't affect the main layout
            }

            function setupLogEntrySelection(logEntry) {
                let isSelecting = false;
                
                // Mouse down - start selection
                logEntry.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left mouse button
                        isSelecting = true;
                        logEntry.classList.add('selecting');
                    }
                });
                
                // Double click - select entire line
                logEntry.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    
                    // Select all text in this log entry
                    const range = document.createRange();
                    range.selectNodeContents(logEntry);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    logEntry.classList.add('selected');
                });
                
                // Mouse up - end selection
                logEntry.addEventListener('mouseup', (e) => {
                    if (isSelecting && e.button === 0) {
                        isSelecting = false;
                        logEntry.classList.remove('selecting');
                        
                        // Check for selection after a short delay
                        setTimeout(() => {
                            const selection = window.getSelection();
                            if (selection && selection.toString().trim()) {
                                logEntry.classList.add('selected');
                            } else {
                                logEntry.classList.remove('selected');
                            }
                        }, 10);
                    }
                });
                
                // Individual selection change handler removed - using global handler
                
                // Handle keyboard shortcuts
                const keyHandler = (e) => {
                    // Don't interfere with input fields
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    
                    if (e.key === 'Escape') {
                        // Clear selection on Escape
                        window.getSelection().removeAllRanges();
                        logEntry.classList.remove('selected');
                    } else if (e.ctrlKey && e.key === 'a' && logEntry.contains(document.activeElement)) {
                        // Select all text in this entry
                        e.preventDefault();
                        const range = document.createRange();
                        range.selectNodeContents(logEntry);
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                };
                
                document.addEventListener('keydown', keyHandler);
                logEntry._keyHandler = keyHandler;
            }
            
            function setupExistingConsoleMessages() {
                // Setup selection for any existing console messages
                const existingMessages = consoleOutput.querySelectorAll('.console-message:not(.log-entry)');
                existingMessages.forEach(msg => {
                    msg.classList.add('log-entry');
                    setupLogEntrySelection(msg);
                });
            }
            
            // Cache for performance optimization
            let lastSelectionState = null;
            
            function updateAllConsoleSelections() {
                const selection = window.getSelection();
                const selectionText = selection ? selection.toString().trim() : '';
                
                // Check if selection state actually changed
                const currentState = selectionText + '_' + (selection ? selection.rangeCount : 0);
                if (currentState === lastSelectionState) {
                    return; // No change, skip update
                }
                lastSelectionState = currentState;
                
                if (!selectionText) {
                    // Clear all selections if no text is selected
                    const selectedMessages = consoleOutput.querySelectorAll('.console-message.selected');
                    selectedMessages.forEach(msg => msg.classList.remove('selected'));
                    return;
                }
                
                // Get all ranges in the selection
                const ranges = [];
                for (let i = 0; i < selection.rangeCount; i++) {
                    ranges.push(selection.getRangeAt(i));
                }
                
                // Get all console messages
                const allMessages = consoleOutput.querySelectorAll('.console-message');
                const selectedMessages = new Set();
                
                // Check each range against all messages
                ranges.forEach(range => {
                    const selectionStart = range.startContainer;
                    const selectionEnd = range.endContainer;
                    
                    allMessages.forEach(msg => {
                        // Simple and fast check: does this message contain selection start or end?
                        if (msg.contains(selectionStart) || msg.contains(selectionEnd)) {
                            selectedMessages.add(msg);
                        }
                    });
                });
                
                // Update classes efficiently - only change what actually changed
                allMessages.forEach(msg => {
                    const shouldBeSelected = selectedMessages.has(msg);
                    const isCurrentlySelected = msg.classList.contains('selected');
                    
                    if (shouldBeSelected && !isCurrentlySelected) {
                        msg.classList.add('selected');
                    } else if (!shouldBeSelected && isCurrentlySelected) {
                        msg.classList.remove('selected');
                    }
                });
            }
            
            function cleanupLogEntrySelection(logEntry) {
                // Clean up event listeners
                if (logEntry._keyHandler) {
                    document.removeEventListener('keydown', logEntry._keyHandler);
                    logEntry._keyHandler = null;
                }
            }

            function logToConsole(message, type = 'log') {
                if (!isLoggingEnabled || isLoggingToConsole) return;
                
                isLoggingToConsole = true;
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry console-message ${type}`;
                    logEntry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;

                    // Add text selection functionality
                    setupLogEntrySelection(logEntry);

                    consoleOutput.appendChild(logEntry);

                    // Auto-scroll to bottom if enabled
                    if (isAutoScrollEnabled) {
                        // Batch scroll update to minimize reflow
                        requestAnimationFrame(() => {
                            try {
                                consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                            } catch (error) {
                                // Don't use console.error here to avoid recursion
                                console.warn('Error scrolling console output:', error);
                            }
                        });
                    }
                } finally {
                    isLoggingToConsole = false;
                }
            }



            // Context menu functionality moved to ConsoleContextMenu class

            function copyToClipboard(text) {
                if (navigator.clipboard && window.isSecureContext) {
                    // Use modern clipboard API with proper error handling
                    navigator.clipboard.writeText(text).then(() => {
                        logToConsole(`Copied to clipboard: ${text}`, 'info');
                    }).catch(err => {
                        console.warn('Clipboard API failed, using fallback:', err);
                        fallbackCopyToClipboard(text);
                    });
                } else {
                    fallbackCopyToClipboard(text);
                }
            }
            
            function fallbackCopyToClipboard(text) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    logToConsole(`Copied to clipboard: ${text}`, 'info');
                } catch (err) {
                    logToConsole(`Failed to copy: ${err.message}`, 'error');
                }
                
                document.body.removeChild(textArea);
            }

            function executeCommand(command) {
                logToConsole(`> ${command}`, 'info');
                
                try {
                    // Basic command parsing
                    const parts = command.split(' ');
                    const cmd = parts[0].toLowerCase();
                    
                    switch (cmd) {
                        case 'help':
                            logToConsole('Available commands:', 'info');
                            logToConsole('  help - Show this help message', 'info');
                            logToConsole('  clear - Clear console output', 'info');
                            logToConsole('  autoscroll - Toggle auto-scroll', 'info');
                            logToConsole('  version - Show editor version', 'info');
                            logToConsole('  objects - Show object count', 'info');
                            logToConsole('  level - Show level info', 'info');
                            break;
                            
                        case 'clear':
                            consoleOutput.innerHTML = '';
                            break;
                            
                        case 'autoscroll':
                            if (window.toggleAutoScroll) {
                                window.toggleAutoScroll();
                            } else {
                                logToConsole('Auto-scroll function not available', 'error');
                            }
                            break;
                            
                        case 'version':
                            const version = window.editor ? window.editor.constructor.VERSION : 'unknown';
                            logToConsole(`2D Level Editor v${version}`, 'info');
                            break;
                            
                        case 'objects':
                            if (window.editor && window.editor.getLevel) {
                                const level = window.editor.getLevel();
                                const count = level.objects.length;
                                logToConsole(`Total objects: ${count}`, 'info');
                            } else {
                                logToConsole('Editor not available', 'error');
                            }
                            break;
                            
                        case 'level':
                            if (window.editor && window.editor.getLevel) {
                                const level = window.editor.getLevel();
                                logToConsole(`Level: ${level.meta.name || 'Unnamed'}`, 'info');
                                logToConsole(`Objects: ${level.objects.length}`, 'info');
                            } else {
                                logToConsole('Editor not available', 'error');
                            }
                            break;
                            
                        default:
                            logToConsole(`Unknown command: ${cmd}. Type 'help' for available commands.`, 'warn');
                    }
                } catch (error) {
                    logToConsole(`Error: ${error.message}`, 'error');
                }
            }

            // Override console methods to also log to our console
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;

            console.log = function(...args) {
                if (originalLog && typeof originalLog === 'function') {
                    originalLog.apply(console, args);
                }
                if (isLoggingEnabled && !isLoggingToConsole) {
                    logToConsole(args.join(' '), 'log');
                }
            };

            console.error = function(...args) {
                if (originalError && typeof originalError === 'function') {
                    originalError.apply(console, args);
                }
                if (isLoggingEnabled && !isLoggingToConsole) {
                    logToConsole(args.join(' '), 'error');
                }
            };

            console.warn = function(...args) {
                if (originalWarn && typeof originalWarn === 'function') {
                    originalWarn.apply(console, args);
                }
                if (isLoggingEnabled && !isLoggingToConsole) {
                    logToConsole(args.join(' '), 'warn');
                }
            };

            // Make editor available globally for console commands
            try {
                window.editor = editor;
            } catch (error) {
                console.error('Error setting global editor:', error);
            }

            // Register console context menu with the manager
            if (window.editor && window.editor.contextMenuManager) {
                try {
                    window.editor.contextMenuManager.registerMenu('console', consoleContextMenu);
                } catch (error) {
                    console.error('Error registering console context menu:', error);
                }
            }

            // Console visibility is now applied immediately in applyUserSettingsImmediately() to prevent UI flicker

            // Initial console message
            try {
                const version = window.editor ? window.editor.constructor.VERSION : 'unknown';
                logToConsole(`2D Level Editor v${version} - Console ready`, 'info');
                logToConsole('Press ` to toggle console, type "help" for commands', 'info');
                
                // Scroll to bottom after initial messages if console is visible
                if (!consolePanel.classList.contains('hidden') && isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            console.warn('Error scrolling console output on init:', error);
                        }
                    });
                }
            } catch (error) {
                console.error('Error logging initial console message:', error);
            }
            
        } catch (error) {
            console.error('Error in setupConsole:', error);
        }
    }

        // Initialize console
        try {
            setupConsole();
            
            // Synchronize console visibility state after initialization
            const consolePanel = document.getElementById('console-panel');
            if (consolePanel) {
                // Update isConsoleVisible to match actual state
                isConsoleVisible = !consolePanel.classList.contains('hidden');
            }
        } catch (error) {
            console.error('Error initializing console:', error);
        }
        
        // Test context menu functionality
        window.testContextMenu = () => {
            try {
                const consolePanel = document.getElementById('console-panel');
                if (consolePanel) {
                    consolePanel.classList.remove('hidden');
                }
            } catch (error) {
                console.error('Error in testContextMenu:', error);
            }
        };
        
        // Update canvas after complete initialization
        const updateCanvasOnStartup = () => {
            try {
                // Update canvas only (no layout changes to avoid panel drift)
                if (window.editor && window.editor.canvasRenderer) {
                    window.editor.canvasRenderer.resizeCanvas();
                    window.editor.render();
                }
                
                // Additional update after a longer delay to ensure everything is settled
                setTimeout(() => {
                    try {
                        if (window.editor && window.editor.canvasRenderer) {
                            window.editor.canvasRenderer.resizeCanvas();
                            window.editor.render();
                        }
                    } catch (error) {
                        console.error('Error in delayed canvas update:', error);
                    }
                }, 500);
            } catch (error) {
                console.error('Error updating canvas on startup:', error);
            }
        };
        
        // Wait for DOM to be fully ready and styles applied
        if (document.readyState === 'complete') {
            try {
                setTimeout(updateCanvasOnStartup, 100);
            } catch (error) {
                console.error('Error in setTimeout:', error);
            }
        } else {
            window.addEventListener('load', () => {
                try {
                    setTimeout(updateCanvasOnStartup, 100);
                } catch (error) {
                    console.error('Error in load event handler:', error);
                }
            });
        }
    </script>
</body>
</html>

