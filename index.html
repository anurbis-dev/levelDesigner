<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D Level Editor v3.51.8</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <!-- Load Tailwind CSS for quick styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Apply user settings immediately to prevent visual jumps -->
    <script>
        // Apply user settings immediately, before any rendering
        (function() {
            try {
                const stored = localStorage.getItem('levelEditor_userConfig_complete');
                if (stored) {
                    const prefs = JSON.parse(stored);
                    const fontScale = prefs.ui?.fontScale || 1.0;
                    const spacingScale = prefs.ui?.spacing || 1.0;
                    
                    if (fontScale !== 1.0) {
                        // Set CSS custom property immediately
                        document.documentElement.style.setProperty('--font-scale', fontScale);
                        document.documentElement.style.fontSize = fontScale * 16 + 'px';
                    }
                    
                    if (spacingScale !== 1.0) {
                        // Set CSS custom property immediately
                        document.documentElement.style.setProperty('--spacing-scale', spacingScale);
                    }
                }
            } catch (error) {
                // Ignore errors during early initialization
            }
        })();
    </script>
    
    <!-- Main styles -->
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/spacing-mode.css">
    <link rel="stylesheet" href="styles/panels.css">
    <link rel="stylesheet" href="styles/layers-panel.css">
    <link rel="stylesheet" href="styles/settings-panel.css">
    <link rel="stylesheet" href="styles/grid-settings.css">
    <link rel="stylesheet" href="styles/details-panel.css">
    <link rel="stylesheet" href="styles/color-chooser.css">
    <link rel="stylesheet" href="styles/base-context-menu.css">
    <link rel="stylesheet" href="styles/canvas-context-menu.css">
    <link rel="stylesheet" href="styles/mobile-dialogs.css">
    <link rel="stylesheet" href="styles/mobile-platform-styles.css">
    <link rel="stylesheet" href="styles/dialog-positioning.css">
    <link rel="stylesheet" href="styles/touch-navigation-prevention.css">
    <link rel="stylesheet" href="styles/console-context-menu.css">
    <link rel="stylesheet" href="styles/user-settings.css">
</head>
<body class="bg-gray-800 text-white font-sans flex flex-col h-screen">

    <!-- 1. Main menu on top -->
    <header class="bg-gray-900 shadow-md flex-shrink-0">
        <nav class="flex items-center justify-between">
            <!-- Menu container - will be populated by MenuManager -->
            <div id="menu-container" class="flex items-center">
                <!-- Menus will be dynamically generated here -->
            </div>
            <div class="text-sm text-gray-400">
                <span id="header-version-info">v3.51.8</span>
            </div>
        </nav>
    </header>

    <!-- Main container with working areas -->
    <div class="flex flex-grow min-h-0">
        <!-- 1. Left Tabs Panel (dynamic, created when needed) -->
        <!-- This will be created dynamically by PanelPositionManager -->
        
        <!-- 2. Main Frame (main workspace) -->
        <main id="main-panel" class="flex-1 flex flex-col bg-gray-700 min-w-0">
            <!-- Toolbar in top part of canvas -->
            <div id="toolbar-container" class="bg-gray-800 flex-shrink-0">
                <!-- Toolbar will be populated by Toolbar component -->
            </div>
            
            <!-- Canvas area -->
            <div class="flex-1 min-h-0">
                <canvas id="main-canvas"></canvas>
            </div>
        </main>

        <!-- 3. Right Tabs Panel (dynamic, created when needed) -->
        <!-- This will be created dynamically by PanelPositionManager -->
    </div>

    <!-- Content panels for right panel tabs (required for initialization) -->
    <div id="details-content-panel" class="tab-content-right" style="display: none;">
        <p class="text-gray-400">Select an object to see its properties.</p>
    </div>
    <div id="layers-content-panel" class="tab-content-right" style="display: none;">
        <!-- Layers content here -->
    </div>
    <div id="outliner-content-panel" class="tab-content-right" style="display: none;">
        <!-- Outliner content here -->
    </div>

        <!-- Separator for changing asset panel height -->
    <div id="resizer-assets" class="resizer-y"></div>

        <!-- 3. Assets Drawer (assets panel) -->
    <footer id="assets-panel" class="h-64 bg-gray-900 flex-shrink-0 flex flex-col relative">
        <div id="asset-tabs-container" class="flex border-b border-gray-700">
            <!-- Tabs will be generated dynamically -->
        </div>
        <div id="asset-previews-container" class="flex-grow overflow-auto p-1">
            <!-- Asset previews container will be generated dynamically -->
        </div>
    </footer>

    <!-- Console Panel as Overlay (hidden by default) -->
    <div id="console-panel" class="console-overlay hidden bg-gray-900 flex flex-col">
        <div id="console-header" class="flex border-b border-gray-700 flex-shrink-0 cursor-pointer hover:bg-gray-800">
            <span class="flex-1 text-sm font-medium text-gray-300 py-2 px-3">Console</span>
            <button id="console-close" class="text-gray-400 hover:text-white hover:bg-gray-700 px-3 py-2 text-lg">&times;</button>
        </div>
        <div class="flex-grow overflow-y-auto">
            <div id="console-output" class="text-gray-300 font-mono text-sm">
                <!-- Console output will be displayed here -->
            </div>
        </div>
        <div class="border-t border-gray-700 flex-shrink-0 flex items-center">
            <span class="text-gray-400 mr-2">&gt;</span>
            <input id="console-input" name="console-input" type="text" placeholder="Enter command..." 
                   class="flex-grow bg-transparent text-gray-300 border-none outline-none font-mono text-sm">
        </div>
        <div class="console-resize-handle"></div>
    </div>

    <!-- Application logic -->
    <script type="module">
        import { LevelEditor } from './src/core/LevelEditor.js';
        import { ConsoleContextMenu } from './src/ui/ConsoleContextMenu.js';
        import { Logger } from './src/utils/Logger.js';
        import { ExtensionErrorUtils } from './src/utils/ExtensionErrorUtils.js';
        import { MenuManager } from './src/managers/MenuManager.js';
        import { UserPreferencesManager } from './src/managers/UserPreferencesManager.js';
            import { eventHandlerManager } from './src/managers/EventHandlerManager.js';
            import { autoEventHandlerManager } from './src/managers/AutoEventHandlerManager.js'; // NEW

        // Safe logging function that works even if Logger is not available
        function safeLog(level, message, ...args) {
            try {
                if (typeof Logger !== 'undefined' && Logger.layout && Logger.layout[level]) {
                    Logger.layout[level](message, ...args);
                } else {
                    console[level === 'error' ? 'error' : 'log'](`[LAYOUT] ${message}`, ...args);
                }
            } catch (error) {
                try {
                    Logger.layout.info(message, ...args);
                } catch (fallbackError) {
                    // Last resort - just log to console
                    console.log(`[LAYOUT] ${message}`);
                }
            }
        }


        // Apply basic user settings IMMEDIATELY to prevent visual jumps
        // This must happen before any DOM manipulation
        function applyUserSettingsImmediately(userPrefs) {
            try {
                // Font scale is applied early in <head> and live via StateManager

                // Apply theme immediately if available
                const theme = userPrefs.get('theme');
                if (theme && theme !== 'dark') {
                    try {
                        document.body.classList.add(`theme-${theme}`);
                    } catch (themeError) {
                        Logger.layout.warn('Failed to apply theme:', themeError);
                    }
                }

                // Apply compact mode immediately
                const compactMode = userPrefs.get('compactMode');
                if (compactMode) {
                    try {
                        document.body.classList.add('compact-mode');
                    } catch (compactError) {
                        Logger.layout.warn('Failed to apply compact mode:', compactError);
                    }
                }

                // Apply panel visibility settings immediately
                // Use stateManager if available, fallback to userPrefs
                let consoleVisible;
                if (window.editor && window.editor.stateManager) {
                    consoleVisible = window.editor.stateManager.get('console.visible');
                } else {
                    consoleVisible = userPrefs.get('consoleVisible');
                }
                
                if (consoleVisible !== undefined) {
                    try {
                        const consolePanel = document.getElementById('console-panel');
                        if (consolePanel) {
                            if (consoleVisible) {
                                consolePanel.classList.remove('hidden');
                            } else {
                                consolePanel.classList.add('hidden');
                            }
                        }
                    } catch (consoleError) {
                        Logger.layout.warn('Failed to apply console visibility:', consoleError);
                    }
                }

                // Apply toolbar visibility immediately
                const toolbarVisible = userPrefs.get('toolbarVisible');
                if (toolbarVisible !== undefined) {
                    try {
                        const toolbarContainer = document.getElementById('toolbar-container');
                        if (toolbarContainer) {
                            if (toolbarVisible) {
                                toolbarContainer.classList.remove('hidden');
                                toolbarContainer.style.display = 'flex';
                            } else {
                                toolbarContainer.classList.add('hidden');
                                toolbarContainer.style.display = 'none';
                            }
                        }
                    } catch (toolbarError) {
                        Logger.layout.warn('Failed to apply toolbar visibility:', toolbarError);
                    }
                }

                // Apply assets panel visibility immediately
                const assetsPanelVisible = userPrefs.get('assetsPanelVisible');
                if (assetsPanelVisible !== undefined) {
                    try {
                        const assetsPanel = document.getElementById('assets-panel');
                        const resizerAssets = document.getElementById('resizer-assets');
                        if (assetsPanel) {
                            if (assetsPanelVisible) {
                                assetsPanel.classList.remove('hidden');
                                assetsPanel.style.display = 'flex';
                                if (resizerAssets) {
                                    resizerAssets.classList.remove('hidden');
                                    resizerAssets.style.display = 'block';
                                }
                            } else {
                                assetsPanel.classList.add('hidden');
                                assetsPanel.style.display = 'none';
                                if (resizerAssets) {
                                    resizerAssets.classList.add('hidden');
                                    resizerAssets.style.display = 'none';
                                }
                            }
                        }
                    } catch (assetsError) {
                        Logger.layout.warn('Failed to apply assets panel visibility:', assetsError);
                    }
                }

                // Apply right panel visibility immediately
                const rightPanelVisible = userPrefs.get('rightPanelVisible');
                if (rightPanelVisible !== undefined) {
                    try {
                        const rightPanel = document.getElementById('right-tabs-panel');
                        const resizerX = document.getElementById('resizer-right-tabs-panel');
                        if (rightPanel) {
                            if (rightPanelVisible) {
                                rightPanel.classList.remove('hidden');
                                rightPanel.style.display = 'flex';
                                if (resizerX) {
                                    resizerX.classList.remove('hidden');
                                    resizerX.style.display = 'block';
                                }
                            } else {
                                rightPanel.classList.add('hidden');
                                rightPanel.style.display = 'none';
                                if (resizerX) {
                                    resizerX.classList.add('hidden');
                                    resizerX.style.display = 'none';
                                }
                            }
                        }
                    } catch (rightError) {
                        Logger.layout.warn('Failed to apply right panel visibility:', rightError);
                    }
                }

                // Apply panel sizes immediately to prevent UI flicker
                try {
                    // Right panel width (will be set by StateManager after editor initialization)

                    // Assets panel height (will be set by StateManager after editor initialization)

                    // Console height with mobile-aware limits
                    const consoleHeight = userPrefs.get('consoleHeight');
                    if (consoleHeight) {
                        const consolePanel = document.getElementById('console-panel');
                        if (consolePanel) {
                            // Adaptive max height based on device type and window size
                            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                            const maxHeight = isMobile ? window.innerHeight * 0.7 : window.innerHeight * 0.9;
                            const height = Math.max(200, Math.min(maxHeight, consoleHeight));
                            consolePanel.style.setProperty('height', height + 'px', 'important');
                            consolePanel.style.setProperty('bottom', 'auto', 'important');
                        }
                    }
                } catch (sizeError) {
                    Logger.layout.warn('Failed to apply panel sizes:', sizeError);
                }

            } catch (error) {
                Logger.layout.warn('Failed to apply user settings immediately:', error);
            }
        }

        // Mobile Interface Manager - Initialize FIRST
        let MobileInterfaceManager;
        try {
            const { mobileInterfaceManager } = await import('./src/managers/MobileInterfaceManager.js');
            MobileInterfaceManager = mobileInterfaceManager;
            Logger.mobile.info('📱 Mobile Interface Manager initialized');
        } catch (error) {
            Logger.mobile.warn('Mobile Interface Manager initialization failed:', error);
            // Create fallback mobile manager
            MobileInterfaceManager = {
                isMobile: () => false,
                isIOS: () => false,
                isAndroid: () => false,
                adaptElement: () => {},
                applyMobileStyles: () => {}
            };
        }

        // Mobile Scaling - Initialize SECOND
        let MobileScalingUtils;
        try {
            const { MobileScalingUtils: MS } = await import('./src/utils/MobileScalingUtils.js');
            MobileScalingUtils = MS;
            MobileScalingUtils.initializeScaling();
            MobileScalingUtils.setupMobileListeners();
        } catch (error) {
            Logger.mobile.warn('Mobile scaling initialization failed:', error);
            // Create fallback mobile scaling utils
            MobileScalingUtils = {
                initializeScaling: () => {},
                setupMobileListeners: () => {},
                isMobileDevice: () => false,
                applyMobileDialogScaling: () => {}
            };
        }

        // User Preferences Manager - Initialize BEFORE LevelEditor

        // Initialize preferences manager FIRST
        let userPrefs;
        try {
            userPrefs = new UserPreferencesManager();
        } catch (error) {
            Logger.preferences.warn('Error creating UserPreferencesManager:', error);
            // Create a fallback preferences manager
            userPrefs = {
                get: () => undefined,
                set: () => {},
                update: () => {}
            };
        }

        // Set up global error handler to filter extension errors
        window.addEventListener('error', (event) => {
            if (ExtensionErrorUtils.isExtensionError(event.error)) {
                // Silently ignore extension errors to prevent user confusion
                console.warn('Extension error filtered:', event.error?.message || event.message);
                event.preventDefault();
                return false;
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            if (ExtensionErrorUtils.isExtensionError(event.reason)) {
                // Silently ignore extension-related promise rejections
                console.warn('Extension promise rejection filtered:', event.reason?.message || event.reason);
                event.preventDefault();
                return false;
            }
        });

        // Apply ALL user settings immediately BEFORE LevelEditor initialization
        try {
            applyUserSettingsImmediately(userPrefs);
        } catch (error) {
            Logger.layout.warn('Error applying user settings immediately:', error);
        }

        // Initialize AutoEventHandlerManager first, before creating LevelEditor
        try {
            window.autoEventHandlerManager = autoEventHandlerManager;
            
            // Initialize AutoEventHandlerManager after DOM is ready
            if (autoEventHandlerManager && typeof autoEventHandlerManager.init === 'function') {
                autoEventHandlerManager.init();
                Logger.lifecycle.info('AutoEventHandlerManager initialized');
            }
        } catch (error) {
            Logger.lifecycle.warn('Error initializing AutoEventHandlerManager:', error);
        }

        // Initialize the level editor with user preferences
        let editor;
        try {
            editor = new LevelEditor(userPrefs);
        } catch (error) {
            Logger.lifecycle.warn('Error creating LevelEditor:', error);
            // Create a fallback editor
            editor = {
                init: () => Promise.resolve(),
                render: () => {},
                canvasRenderer: { resizeCanvas: () => {} },
                stateManager: { get: () => undefined, set: () => {} },
                eventHandlers: { togglePanel: () => {} },
                contextMenuManager: { registerMenu: () => {} }
            };
        }

        // Make editor globally available
        try {
            window.editor = editor;
            window.consoleContextMenu = consoleContextMenu;

            // Force check for any windows that might have been created during LevelEditor initialization
            if (autoEventHandlerManager && typeof autoEventHandlerManager.checkForNewWindow === 'function') {
                // Check document.body for any windows that might have been created
                const windows = document.querySelectorAll('[id*="overlay"], [id*="dialog"], [id*="window"]');
                windows.forEach(window => {
                    autoEventHandlerManager.checkForNewWindow(window);
                });
            }
        } catch (error) {
            Logger.console.error('Error setting global editor early:', error);
        }

        // Initialize the editor
        try {
            editor.init().then(() => {
                // Panel sizes are now applied immediately before LevelEditor initialization to prevent UI flicker
                Logger.lifecycle.info('Level Editor initialized successfully');

                // Register pending windows after LevelEditor initialization
                try {
                    if (autoEventHandlerManager && typeof autoEventHandlerManager.registerPendingWindows === 'function') {
                        Logger.lifecycle.debug('Registering pending windows after LevelEditor init');
                        autoEventHandlerManager.registerPendingWindows();
                    }
                } catch (error) {
                    Logger.lifecycle.warn('Error registering pending windows:', error);
                }
            }).catch(error => {
                Logger.lifecycle.warn('Failed to initialize level editor:', error);
                // Don't show alert for async response errors from extensions
                if (!ExtensionErrorUtils.isExtensionError(error)) {
                    try {
                        alert('Failed to initialize level editor: ' + (error.message || error));
                    } catch (alertError) {
                        Logger.lifecycle.warn('Failed to show alert:', alertError);
                    }
                } else {
                    // Log extension error silently to avoid user confusion
                    Logger.lifecycle.warn('Extension-related error ignored:', error.message);
                }
            });
        } catch (error) {
            Logger.lifecycle.warn('Error calling editor.init():', error);
        }

        // User preferences manager is already initialized above

        // Console height is now applied immediately in applyUserSettingsImmediately() to prevent UI flicker

        // Panel sizes are now applied immediately before LevelEditor initialization to prevent UI flicker

            // Function to force complete layout update
            function forceLayoutUpdate() {
                try {
                    // Get main elements
                    const mainContainer = document.querySelector('.flex.flex-grow.min-h-0');
                    const mainPanel = document.getElementById('main-panel');
                    const rightPanel = document.getElementById('right-tabs-panel');
                    const assetsPanel = document.getElementById('assets-panel');
                    const consolePanel = document.getElementById('console-panel');

                // Only reset console styles when hidden - preserve other panel sizes
                // Don't reset height as it's managed by user preferences
                if (consolePanel.classList.contains('hidden')) {
                    consolePanel.style.flexShrink = '';
                    consolePanel.style.display = '';
                    // Height is preserved and restored from user preferences when shown
                }

                // Minimal reflow trigger - only for main container to avoid affecting panel positions
                if (mainContainer) {
                    // Use getComputedStyle instead of offsetHeight to avoid layout changes
                    const computedStyle = getComputedStyle(mainContainer);
                    // This triggers a minimal reflow without changing layout
                    const _ = computedStyle.height;
                }

                // Update canvas and render immediately
                updateCanvas();
                } catch (error) {
                    Logger.layout.error('Error in forceLayoutUpdate:', error);
                }
            }

            // Function to update canvas layout (called when panels show/hide)
            function updateCanvasLayout() {
                try {
                    // Only update canvas without forcing full layout to avoid panel drift
                    if (window.editor && window.editor.canvasRenderer) {
                        window.editor.canvasRenderer.resizeCanvas();
                        window.editor.render();
                    }
                } catch (error) {
                    Logger.layout.error('Error in updateCanvasLayout:', error);
                }
            }

        // Optimized canvas update function to avoid duplicate calls (global)
        function updateCanvas() {
            if (window.editor && window.editor.canvasRenderer) {
                window.editor.canvasRenderer.resizeCanvas();
                window.editor.render();
            }
        }

        // Make updateCanvas globally available
        window.updateCanvas = updateCanvas;

        // Assets panel resizing is now handled by PanelPositionManager
                if (window.editor?.stateManager) {
                    const assetsPanelHeight = window.editor.stateManager.get('panels.assetsPanelHeight');
                    
                    // Note: Right panel width is now handled by PanelPositionManager
                    
                    // Apply assets panel height
                    if (assetsPanelHeight !== undefined) {
                        const assetsPanel = document.getElementById('assets-panel');
                        if (assetsPanel) {
                            assetsPanel.style.height = assetsPanelHeight + 'px';
                            assetsPanel.style.flexShrink = '0';
                        }
                    }
                }
                
                const resizerAssets = document.getElementById('resizer-assets');
                const assetsPanel = document.getElementById('assets-panel');

                // Universal function for applying panel styles
                function applyPanelStyles(panel, size, direction = 'width', display = 'flex') {
                    if (direction === 'width') {
                        panel.style.width = size + 'px';
                        panel.style.flex = '0 0 auto';
                    } else {
                        panel.style.height = size + 'px';
                        panel.style.flexShrink = '0';
                    }
                    panel.style.display = display;
                }

            let isResizingAssets = false;
            let isAnyResizing = false; // Track any resizing activity
            
            // Variables to track initial positions for resizing
            let initialMouseY = 0;
            let initialAssetsPanelHeight = 0;
            
            // Previous states for double-click toggle
            let previousAssetsPanelHeight = 256; // Default height

            // Initialize previous states from StateManager
            const savedAssetsPanelHeight = window.editor?.stateManager?.get('panels.assetsPanelHeight');
            if (savedAssetsPanelHeight && savedAssetsPanelHeight > 0) {
                previousAssetsPanelHeight = savedAssetsPanelHeight;
            }

            // Note: Right panel resizer is now handled by PanelPositionManager

            // Assets panel resizer (between main area and assets panel)
            resizerAssets.addEventListener('mousedown', (e) => {
                isResizingAssets = true;
                isAnyResizing = true;
                initialMouseY = e.clientY;
                initialAssetsPanelHeight = assetsPanel.offsetHeight;
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                resizerAssets.classList.add('resizing');
                e.preventDefault();
                e.stopPropagation();
            });

            // Double-click handler for resizerAssets
            resizerAssets.addEventListener('dblclick', (e) => {
                Logger.layout.info('Assets panel resizer double-click triggered');
                e.preventDefault();
                e.stopPropagation();

                const currentHeight = assetsPanel.offsetHeight;
                const minHeight = 0;

                // Check if already at minimum (collapsed)
                if (currentHeight <= minHeight) {
                    // Restore to previous height
                    if (window.editor?.stateManager) {
                        window.editor.stateManager.set('panels.assetsPanelHeight', previousAssetsPanelHeight);
                    }
                } else {
                    // Save current height and collapse
                    previousAssetsPanelHeight = currentHeight;
                    if (window.editor?.stateManager) {
                        window.editor.stateManager.set('panels.assetsPanelHeight', 0);
                    }
                }

                updateCanvas();
            });


            // Mouse move handler for assets panel resizer
            const handleAssetsMouseMove = (e) => {
                if (!isResizingAssets) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                // Calculate height based on mouse movement from initial position
                const mouseDelta = e.clientY - initialMouseY;
                const newHeight = initialAssetsPanelHeight - mouseDelta; // Inverted direction
                
                // Apply directly without any limits
                assetsPanel.style.height = newHeight + 'px';
                assetsPanel.style.flexShrink = '0';

                // Save to StateManager
                if (window.editor?.stateManager) {
                    window.editor.stateManager.set('panels.assetsPanelHeight', newHeight);
                }

                // Update canvas and render
                if (window.editor && window.editor.canvasRenderer) {
                    window.editor.canvasRenderer.resizeCanvas();
                    window.editor.render();
                }
            };

            // Mouse up handler for assets panel resizer
            const handleAssetsMouseUp = (e) => {
                if (isResizingAssets) {
                    isResizingAssets = false;
                    isAnyResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    resizerAssets.classList.remove('resizing');
                    e.preventDefault();
                    e.stopPropagation();
                }
            };

            // Add global mouse events for assets resizer (only if not already added)
            if (!resizerAssets._globalListenersAdded) {
                document.addEventListener('mousemove', handleAssetsMouseMove);
                document.addEventListener('mouseup', handleAssetsMouseUp);
                resizerAssets._globalListenersAdded = true;
            }

            // Touch support for assets panel resizer will be handled by LevelEditor

            // Prevent text selection during resize
            document.addEventListener('selectstart', (e) => {
                if (isResizingAssets) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent context menu during resize
            document.addEventListener('contextmenu', (e) => {
                if (isResizingAssets) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent drag during resize
            document.addEventListener('dragstart', (e) => {
                if (isResizingAssets) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Prevent focus changes during resize
            document.addEventListener('focusin', (e) => {
                if (isResizingAssets) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });


        // Tab dragging functionality
        function setupTabDragging() {
            try {
                // Initialize global dragging state
                if (!window.tabDraggingState) {
                    window.tabDraggingState = {
                        draggedTab: null,
                        draggedIndex: -1,
                        draggedPanel: null
                    };
                }

                // Setup dragging for a specific tab container
                function setupContainerDragging(tabContainer) {
                    if (!tabContainer) return;

                    const draggingState = window.tabDraggingState;

                    // Make tabs draggable
                    tabContainer.addEventListener('mousedown', (e) => {
                        const tab = e.target.closest('.tab-right, .tab-left');
                        if (!tab) return;

                        draggingState.draggedTab = tab;
                        draggingState.draggedIndex = Array.from(tabContainer.children).indexOf(tab);
                        draggingState.draggedPanel = tabContainer.closest('[id$="-tabs-panel"]');
                        
                        // Add dragging class
                        tab.classList.add('dragging');
                        
                        // Prevent default to avoid text selection
                        e.preventDefault();
                    });

                    // Handle mouse move for drag over effects
                    tabContainer.addEventListener('mousemove', (e) => {
                        if (!draggingState.draggedTab || draggingState.draggedPanel !== tabContainer.closest('[id$="-tabs-panel"]')) return;

                        const tab = e.target.closest('.tab-right, .tab-left');
                        if (!tab || tab === draggingState.draggedTab) {
                            // Remove drag-over from all tabs in this container
                            tabContainer.querySelectorAll('.tab-right, .tab-left').forEach(t => t.classList.remove('tab-drag-over'));
                            return;
                        }

                        const targetIndex = Array.from(tabContainer.children).indexOf(tab);
                        
                        // Remove drag-over from all tabs in this container
                        tabContainer.querySelectorAll('.tab-right, .tab-left').forEach(t => t.classList.remove('tab-drag-over'));
                        
                        // Add drag-over to target tab
                        tab.classList.add('tab-drag-over');
                    });

                    // Prevent text selection during drag
                    tabContainer.addEventListener('selectstart', (e) => {
                        if (draggingState.draggedTab) {
                            e.preventDefault();
                        }
                    });
                }

                // Setup dragging for right panel
                const rightTabContainer = document.querySelector('#right-tabs-panel .flex.border-b.border-gray-700');
                setupContainerDragging(rightTabContainer);

                // Setup dragging for left panel (will be added dynamically)
                const leftTabContainer = document.querySelector('#left-tabs-panel .flex.border-b.border-gray-700');
                setupContainerDragging(leftTabContainer);

                // Handle mouse up to complete drag
                document.addEventListener('mouseup', (e) => {
                    const draggingState = window.tabDraggingState;
                    if (!draggingState.draggedTab) return;

                    const tabContainer = draggingState.draggedTab.parentElement;
                    const targetTab = e.target.closest('.tab-right, .tab-left');
                    
                    if (targetTab && targetTab !== draggingState.draggedTab && tabContainer.contains(targetTab)) {
                        const targetIndex = Array.from(tabContainer.children).indexOf(targetTab);
                        const draggedIndex = Array.from(tabContainer.children).indexOf(draggingState.draggedTab);
                        
                        // Move the tab within the same container
                        if (draggedIndex < targetIndex) {
                            tabContainer.insertBefore(draggingState.draggedTab, targetTab.nextSibling);
                        } else {
                            tabContainer.insertBefore(draggingState.draggedTab, targetTab);
                        }
                    }

                    // Clean up
                    tabContainer.querySelectorAll('.tab-right, .tab-left').forEach(t => {
                        t.classList.remove('dragging', 'tab-drag-over');
                    });
                    
                    draggingState.draggedTab = null;
                    draggingState.draggedIndex = -1;
                    draggingState.draggedPanel = null;
                });
            } catch (error) {
                Logger.layout.error('Error setting up tab dragging:', error);
            }
        }

        // Initialize tab dragging
        try {
            setupTabDragging();
        } catch (error) {
            Logger.layout.error('Error initializing tab dragging:', error);
        }

        // Console functionality
        let isConsoleVisible = false; // Global variable for console visibility state
        let isLoggingToConsole = false; // Global variable to prevent infinite recursion in console logging
        
        function setupConsole() {
            try {
                const consolePanel = document.getElementById('console-panel');
                const consoleOutput = document.getElementById('console-output');
                const consoleInput = document.getElementById('console-input');
                const consoleClose = document.getElementById('console-close');
                // Get the scrollable container (parent of console-output)
                const consoleScrollContainer = consoleOutput.parentElement;
                let isLoggingEnabled = true;
                
                // Global auto-scroll state (moved here to be accessible by all console functions)
                let isAutoScrollEnabled = true;

            // Function to toggle auto-scroll
            function toggleAutoScroll() {
                isAutoScrollEnabled = !isAutoScrollEnabled;
                logToConsole(`Auto-scroll ${isAutoScrollEnabled ? 'enabled' : 'disabled'}`, 'info');
                
                // If enabling auto-scroll, scroll to bottom immediately
                if (isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            Logger.console.warn('Error scrolling console output:', error);
                        }
                    });
                }
            }

            // Function to force scroll to bottom (used when enabling auto-scroll)
            function scrollToBottom() {
                if (isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            Logger.console.warn('Error scrolling console output:', error);
                        }
                    });
                }
            }

            // Make toggleAutoScroll globally accessible for console commands
            window.toggleAutoScroll = toggleAutoScroll;

            // Initialize console context menu
            const consoleContextMenu = new ConsoleContextMenu(consolePanel, consoleOutput, {
                onLoggingToggle: (enabled) => {
                    // Update both local and context menu state
                    isLoggingEnabled = enabled;
                    logToConsole(`Logging ${enabled ? 'enabled' : 'disabled'}`, 'info');
                },
                onAutoScrollToggle: () => {
                    toggleAutoScroll();
                },
                onConsoleClear: () => {
                    logToConsole('Console cleared', 'info');
                },
                onCopyToClipboard: (text) => {
                    logToConsole(`Copied to clipboard: ${text}`, 'info');
                }
            });

            // Setup scroll listener to detect manual scrolling
            let scrollTimeout = null;
            consoleScrollContainer.addEventListener('scroll', () => {
                // Clear existing timeout
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                
                // Set a timeout to detect if user scrolled manually
                scrollTimeout = setTimeout(() => {
                    const isAtBottom = Math.abs(consoleScrollContainer.scrollTop - (consoleScrollContainer.scrollHeight - consoleScrollContainer.clientHeight)) < 5;
                    
                    // If user scrolled up manually and auto-scroll was enabled, disable it
                    if (!isAtBottom && isAutoScrollEnabled) {
                        isAutoScrollEnabled = false;
                        logToConsole('Auto-scroll disabled (user scrolled up)', 'info');
                    }
                }, 150); // Small delay to distinguish between manual and automatic scrolling
            });
            
            // Setup selection for existing console messages
            setupExistingConsoleMessages();
            
            // Global selection change handler for all console messages (throttled)
            let selectionTimeout = null;
            document.addEventListener('selectionchange', () => {
                if (selectionTimeout) {
                    clearTimeout(selectionTimeout);
                }
                selectionTimeout = setTimeout(() => {
                    updateAllConsoleSelections();
                }, 50); // Throttle to 50ms
            });

            // Register console context menu with the manager after editor is initialized
            // This will be done after the editor initialization completes

            // Toggle console with backtick key
            document.addEventListener('keydown', (e) => {
                if (e.key === '`' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    // Use the new unified panel system instead of old toggleConsole()
                    if (window.editor && window.editor.eventHandlers) {
                        window.editor.eventHandlers.togglePanel('console');
                    } else {
                        // Fallback to old method if editor not ready
                        toggleConsole();
                    }
                }
            });

            // Unified console close handler
            function closeConsole(e) {
                if (e) e.stopPropagation(); // Prevent event bubbling
                
                // Force hide context menu when console is closed
                if (consoleContextMenu && typeof consoleContextMenu.forceHideMenu === 'function') {
                    consoleContextMenu.forceHideMenu();
                }
                
                // Use unified panel system
                if (window.editor && window.editor.eventHandlers) {
                    window.editor.eventHandlers.togglePanel('console');
                } else {
                    hideConsole(); // Fallback
                }
            }

            // Console header click to close
            const consoleHeader = document.getElementById('console-header');
            consoleHeader.addEventListener('click', closeConsole);

            // Close console button
            consoleClose.addEventListener('click', closeConsole);

            // Touch support for console header and close button will be handled by LevelEditor

            // Context menu is now handled by ConsoleContextMenu class

            // Console input handling
            consoleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const command = consoleInput.value.trim();
                    if (command) {
                        executeCommand(command);
                        consoleInput.value = '';
                    }
                } else if (e.key === 'Escape') {
                    hideConsole();
                }
            });

            // Console resize functionality
            setupConsoleResizing();

            function setupConsoleResizing() {
                const resizeHandle = consolePanel.querySelector('.console-resize-handle');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                // Mouse resize functionality
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = consolePanel.offsetHeight;
                    document.body.style.cursor = 'row-resize';
                    document.body.style.userSelect = 'none';
                    resizeHandle.classList.add('resizing');
                    e.preventDefault();
                });

                // Mouse move handler for console resizer
                const handleConsoleMouseMove = (e) => {
                    if (!isResizing) return;

                    const deltaY = e.clientY - startY;
                    const newHeight = startHeight + deltaY;
                    const minHeight = 200;
                    
                    // Adaptive max height based on device type and window size
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                    const maxHeight = isMobile ? window.innerHeight * 0.7 : window.innerHeight * 0.9;

                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        consolePanel.style.height = newHeight + 'px';
                        consolePanel.style.bottom = 'auto';
                        
                        // Don't save during resize - only save on mouseup
                    }
                };

                // Mouse up handler for console resizer
                const handleConsoleMouseUp = () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        resizeHandle.classList.remove('resizing');
                        
                        // Save the final height when resize is complete
                        const finalHeight = consolePanel.offsetHeight;
                        userPrefs.set('consoleHeight', finalHeight);
                        
                        // Also save to StateManager if available
                        if (window.editor && window.editor.stateManager) {
                            window.editor.stateManager.set('panels.consoleHeight', finalHeight);
                        }
                    }
                };

                // Add global mouse events for console resizer (only if not already added)
                if (!resizeHandle._globalListenersAdded) {
                    document.addEventListener('mousemove', handleConsoleMouseMove);
                    document.addEventListener('mouseup', handleConsoleMouseUp);
                    resizeHandle._globalListenersAdded = true;
                }

                // Double-click handler for console resizer
                resizeHandle.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close console on double-click
                    closeConsole();
                    Logger.ui.info('Console closed via double-click on resizer');
                });

                // Touch support for console resizer will be handled by LevelEditor
            }

            function toggleConsole() {
                if (isConsoleVisible) {
                    hideConsole();
                } else {
                    showConsole();
                }
            }

            function showConsole() {
                const showConsolePanel = consolePanel; // Use the consolePanel from outer scope

                // Ensure correct height before showing
                const savedConsoleHeight = userPrefs.get('consoleHeight');
                if (savedConsoleHeight && savedConsoleHeight > 0) {
                    const correctHeight = Math.max(200, Math.min(window.innerHeight * 0.9, savedConsoleHeight));
                    showConsolePanel.style.setProperty('height', correctHeight + 'px', 'important');
                }

                showConsolePanel.classList.remove('hidden');
                consoleInput.focus();
                isConsoleVisible = true;

                // Save preference - use stateManager if available
                if (window.editor && window.editor.stateManager) {
                    window.editor.stateManager.set('console.visible', true);
                } else {
                    userPrefs.set('consoleVisible', true);
                }

                // Scroll to bottom when console is opened
                if (isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            Logger.console.warn('Error scrolling console output on show:', error);
                        }
                    });
                }
                
                // Console is now an overlay, no need to update canvas layout
                // The overlay covers everything and doesn't affect the main layout
            }

            function hideConsole() {
                consolePanel.classList.add('hidden');
                isConsoleVisible = false;
                
                // Force hide context menu when console is closed
                if (consoleContextMenu && typeof consoleContextMenu.forceHideMenu === 'function') {
                    consoleContextMenu.forceHideMenu();
                }
                
                // Save preference - use stateManager if available
                if (window.editor && window.editor.stateManager) {
                    window.editor.stateManager.set('console.visible', false);
                } else {
                    userPrefs.set('consoleVisible', false);
                }
                
                // Console is now an overlay, no need to update canvas layout
                // The overlay covers everything and doesn't affect the main layout
            }

            function setupLogEntrySelection(logEntry) {
                let isSelecting = false;
                
                // Mouse down - start selection
                logEntry.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left mouse button
                        isSelecting = true;
                        logEntry.classList.add('selecting');
                    }
                });
                
                // Double click - select entire line
                logEntry.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    
                    // Select all text in this log entry
                    const range = document.createRange();
                    range.selectNodeContents(logEntry);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    logEntry.classList.add('selected');
                });
                
                // Mouse up - end selection
                logEntry.addEventListener('mouseup', (e) => {
                    if (isSelecting && e.button === 0) {
                        isSelecting = false;
                        logEntry.classList.remove('selecting');
                        
                        // Check for selection after a short delay
                        setTimeout(() => {
                            const selection = window.getSelection();
                            if (selection && selection.toString().trim()) {
                                logEntry.classList.add('selected');
                            } else {
                                logEntry.classList.remove('selected');
                            }
                        }, 10);
                    }
                });
                
                // Individual selection change handler removed - using global handler
                
                // Handle keyboard shortcuts
                const keyHandler = (e) => {
                    // Don't interfere with input fields
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    
                    if (e.key === 'Escape') {
                        // Clear selection on Escape
                        window.getSelection().removeAllRanges();
                        logEntry.classList.remove('selected');
                    } else if (e.ctrlKey && e.key === 'a' && logEntry.contains(document.activeElement)) {
                        // Select all text in this entry
                        e.preventDefault();
                        const range = document.createRange();
                        range.selectNodeContents(logEntry);
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                };
                
                document.addEventListener('keydown', keyHandler);
                logEntry._keyHandler = keyHandler;
            }
            
            function setupExistingConsoleMessages() {
                // Setup selection for any existing console messages
                const existingMessages = consoleOutput.querySelectorAll('.console-message:not(.log-entry)');
                existingMessages.forEach(msg => {
                    msg.classList.add('log-entry');
                    setupLogEntrySelection(msg);
                });
            }
            
            // Cache for performance optimization
            let lastSelectionState = null;
            
            function updateAllConsoleSelections() {
                const selection = window.getSelection();
                const selectionText = selection ? selection.toString().trim() : '';
                
                // Check if selection state actually changed
                const currentState = selectionText + '_' + (selection ? selection.rangeCount : 0);
                if (currentState === lastSelectionState) {
                    return; // No change, skip update
                }
                lastSelectionState = currentState;
                
                if (!selectionText) {
                    // Clear all selections if no text is selected
                    const selectedMessages = consoleOutput.querySelectorAll('.console-message.selected');
                    selectedMessages.forEach(msg => msg.classList.remove('selected'));
                    return;
                }
                
                // Get all ranges in the selection
                const ranges = [];
                for (let i = 0; i < selection.rangeCount; i++) {
                    ranges.push(selection.getRangeAt(i));
                }
                
                // Get all console messages
                const allMessages = consoleOutput.querySelectorAll('.console-message');
                const selectedMessages = new Set();
                
                // Check each range against all messages
                ranges.forEach(range => {
                    const selectionStart = range.startContainer;
                    const selectionEnd = range.endContainer;
                    
                    allMessages.forEach(msg => {
                        // Simple and fast check: does this message contain selection start or end?
                        if (msg.contains(selectionStart) || msg.contains(selectionEnd)) {
                            selectedMessages.add(msg);
                        }
                    });
                });
                
                // Update classes efficiently - only change what actually changed
                allMessages.forEach(msg => {
                    const shouldBeSelected = selectedMessages.has(msg);
                    const isCurrentlySelected = msg.classList.contains('selected');
                    
                    if (shouldBeSelected && !isCurrentlySelected) {
                        msg.classList.add('selected');
                    } else if (!shouldBeSelected && isCurrentlySelected) {
                        msg.classList.remove('selected');
                    }
                });
            }
            
            function cleanupLogEntrySelection(logEntry) {
                // Clean up event listeners
                if (logEntry._keyHandler) {
                    document.removeEventListener('keydown', logEntry._keyHandler);
                    logEntry._keyHandler = null;
                }
            }

            function logToConsole(message, type = 'log') {
                if (!isLoggingEnabled || isLoggingToConsole) return;
                
                isLoggingToConsole = true;
                try {
                    const timestamp = new Date().toLocaleTimeString();
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry console-message ${type}`;
                    logEntry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;

                    // Add text selection functionality
                    setupLogEntrySelection(logEntry);

                    consoleOutput.appendChild(logEntry);

                    // Auto-scroll to bottom if enabled
                    if (isAutoScrollEnabled) {
                        // Batch scroll update to minimize reflow
                        requestAnimationFrame(() => {
                            try {
                                consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                            } catch (error) {
                                // Don't use console.error here to avoid recursion
                                Logger.console.warn('Error scrolling console output:', error);
                            }
                        });
                    }
                } finally {
                    isLoggingToConsole = false;
                }
            }



            // Context menu functionality moved to ConsoleContextMenu class

            function copyToClipboard(text) {
                if (navigator.clipboard && window.isSecureContext) {
                    // Use modern clipboard API with proper error handling
                    navigator.clipboard.writeText(text).then(() => {
                        logToConsole(`Copied to clipboard: ${text}`, 'info');
                    }).catch(err => {
                        Logger.console.warn('Clipboard API failed, using fallback:', err);
                        fallbackCopyToClipboard(text);
                    });
                } else {
                    fallbackCopyToClipboard(text);
                }
            }
            
            function fallbackCopyToClipboard(text) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    logToConsole(`Copied to clipboard: ${text}`, 'info');
                } catch (err) {
                    logToConsole(`Failed to copy: ${err.message}`, 'error');
                }
                
                document.body.removeChild(textArea);
            }

            function executeCommand(command) {
                logToConsole(`> ${command}`, 'info');
                
                try {
                    // Basic command parsing
                    const parts = command.split(' ');
                    const cmd = parts[0].toLowerCase();
                    
                    switch (cmd) {
                        case 'help':
                            logToConsole('Available commands:', 'info');
                            logToConsole('  help - Show this help message', 'info');
                            logToConsole('  clear - Clear console output', 'info');
                            logToConsole('  autoscroll - Toggle auto-scroll', 'info');
                            logToConsole('  version - Show editor version', 'info');
                            logToConsole('  objects - Show object count', 'info');
                            logToConsole('  level - Show level info', 'info');
                            break;
                            
                        case 'clear':
                            consoleOutput.innerHTML = '';
                            break;
                            
                        case 'autoscroll':
                            if (window.toggleAutoScroll) {
                                window.toggleAutoScroll();
                            } else {
                                logToConsole('Auto-scroll function not available', 'error');
                            }
                            break;
                            
                        case 'version':
                            const version = window.editor ? window.editor.constructor.VERSION : 'unknown';
                            logToConsole(`2D Level Editor v${version}`, 'info');
                            break;
                            
                        case 'objects':
                            if (window.editor && window.editor.getLevel) {
                                const level = window.editor.getLevel();
                                const count = level.objects.length;
                                logToConsole(`Total objects: ${count}`, 'info');
                            } else {
                                logToConsole('Editor not available', 'error');
                            }
                            break;
                            
                        case 'level':
                            if (window.editor && window.editor.getLevel) {
                                const level = window.editor.getLevel();
                                logToConsole(`Level: ${level.meta.name || 'Unnamed'}`, 'info');
                                logToConsole(`Objects: ${level.objects.length}`, 'info');
                            } else {
                                logToConsole('Editor not available', 'error');
                            }
                            break;
                            
                        default:
                            logToConsole(`Unknown command: ${cmd}. Type 'help' for available commands.`, 'warn');
                    }
                } catch (error) {
                    logToConsole(`Error: ${error.message}`, 'error');
                }
            }

            // Override console methods to also log to our console
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;

            console.log = function(...args) {
                if (originalLog && typeof originalLog === 'function') {
                    originalLog.apply(console, args);
                }
                if (isLoggingEnabled && !isLoggingToConsole) {
                    logToConsole(args.join(' '), 'log');
                }
            };

            console.error = function(...args) {
                if (originalError && typeof originalError === 'function') {
                    originalError.apply(console, args);
                }
                if (isLoggingEnabled && !isLoggingToConsole) {
                    logToConsole(args.join(' '), 'error');
                }
            };

            console.warn = function(...args) {
                if (originalWarn && typeof originalWarn === 'function') {
                    originalWarn.apply(console, args);
                }
                if (isLoggingEnabled && !isLoggingToConsole) {
                    logToConsole(args.join(' '), 'warn');
                }
            };


            // Assets panel resizing is now handled by PanelPositionManager

            // Register console context menu with the manager
            if (window.editor && window.editor.contextMenuManager) {
                try {
                    window.editor.contextMenuManager.registerMenu('console', consoleContextMenu);
                } catch (error) {
                    Logger.console.error('Error registering console context menu:', error);
                }
            }

            // Console visibility is now applied immediately in applyUserSettingsImmediately() to prevent UI flicker

            // Initial console message
            try {
                const version = window.editor ? window.editor.constructor.VERSION : 'unknown';
                logToConsole(`2D Level Editor v${version} - Console ready`, 'info');
                logToConsole('Press ` to toggle console, type "help" for commands', 'info');
                
                // Scroll to bottom after initial messages if console is visible
                if (!consolePanel.classList.contains('hidden') && isAutoScrollEnabled) {
                    requestAnimationFrame(() => {
                        try {
                            consoleScrollContainer.scrollTop = consoleScrollContainer.scrollHeight;
                        } catch (error) {
                            Logger.console.warn('Error scrolling console output on init:', error);
                        }
                    });
                }
            } catch (error) {
                Logger.console.error('Error logging initial console message:', error);
            }
            
        } catch (error) {
            Logger.console.error('Error in setupConsole:', error);
        }
    }

        // Initialize console
        try {
            setupConsole();
            
            // Synchronize console visibility state after initialization
            const consolePanel = document.getElementById('console-panel');
            if (consolePanel) {
                // Update isConsoleVisible to match actual state
                isConsoleVisible = !consolePanel.classList.contains('hidden');
                
                // Also sync with stateManager if available
                if (window.editor && window.editor.stateManager) {
                    window.editor.stateManager.set('console.visible', isConsoleVisible);
                }
            }
        } catch (error) {
            Logger.console.error('Error initializing console:', error);
        }
        
        // Test context menu functionality
        window.testContextMenu = () => {
            try {
                const consolePanel = document.getElementById('console-panel');
                if (consolePanel) {
                    consolePanel.classList.remove('hidden');
                }
            } catch (error) {
                Logger.console.error('Error in testContextMenu:', error);
            }
        };
        
        // Update canvas after complete initialization
        const updateCanvasOnStartup = () => {
            try {
                // Update canvas only (no layout changes to avoid panel drift)
                updateCanvas();
                
                // Additional update after a longer delay to ensure everything is settled
                setTimeout(() => {
                    try {
                        if (window.editor && window.editor.canvasRenderer) {
                            window.editor.canvasRenderer.resizeCanvas();
                            window.editor.render();
                        }
                    } catch (error) {
                        Logger.layout.error('Error in delayed canvas update:', error);
                    }
                }, 500);
            } catch (error) {
                Logger.layout.error('Error updating canvas on startup:', error);
            }
        };
        
        // Wait for DOM to be fully ready and styles applied
        if (document.readyState === 'complete') {
            try {
                setTimeout(updateCanvasOnStartup, 100);
            } catch (error) {
                Logger.layout.error('Error in setTimeout:', error);
            }
        } else {
            window.addEventListener('load', () => {
                try {
                    setTimeout(updateCanvasOnStartup, 100);
                } catch (error) {
                    Logger.layout.error('Error in load event handler:', error);
                }
            });
        }
    </script>
</body>
</html>

