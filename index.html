<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Level Editor</title>
    <!-- Подключаем Tailwind CSS для быстрой стилизации -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Дополнительные стили для улучшения внешнего вида и функциональности */
        body, html {
            overflow: hidden; /* Запрещаем прокрутку всей страницы */
            height: 100%;
        }
        /* Стили для разделителей, которые позволят менять размеры панелей */
        .resizer {
            background-color: #374151; /* gray-700 */
            cursor: col-resize;
            width: 6px;
            flex-shrink: 0;
        }
        .resizer-y {
            background-color: #374151; /* gray-700 */
            cursor: row-resize;
            height: 6px;
            flex-shrink: 0;
        }
        /* Стили для холста (основной рабочей зоны) */
        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #4B5563; /* gray-600 */
        }
        /* Стили для табов */
        .tab, .tab-right {
            transition: background-color 0.2s;
        }
        .tab.active, .tab-right.active {
            background-color: #374151; /* gray-700 */
            border-bottom-color: transparent;
        }
        /* Стили для превью ассетов */
        .asset-thumbnail {
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .asset-thumbnail.selected {
            border-color: #3B82F6; /* blue-500 */
        }
        /* Стили для рамки выделения в панели ассетов */
        #asset-marquee {
            position: absolute;
            border: 1px solid rgba(59, 130, 246, 0.8);
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none; /* чтобы не мешала кликам */
            z-index: 100;
        }
        /* Стили для аутлайнера */
        .outliner-item {
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            white-space: nowrap;
        }
        .outliner-item:hover {
            background-color: #374151;
        }
        .outliner-item.selected {
            background-color: #3B82F6;
        }
        .outliner-group-header {
            cursor: pointer;
            font-weight: bold;
            user-select: none;
        }
        .outliner-group-header::before {
            content: '▼ ';
            display: inline-block;
            transition: transform 0.2s;
        }
        .outliner-group-header.collapsed::before {
            transform: rotate(-90deg);
        }
        /* Стили для перетаскивания группы для создания префаба */
        #assets-panel.drop-target {
            box-shadow: 0 0 0 3px #3B82F6 inset;
        }
    </style>
</head>
<body class="bg-gray-800 text-white font-sans flex flex-col h-screen">

    <!-- 1. Основное меню сверху -->
    <header class="bg-gray-900 shadow-md flex-shrink-0">
        <nav class="flex items-center space-x-4 p-2">
            <div class="relative group" id="menu-level">
                <button class="px-3 py-1 rounded hover:bg-gray-700 transition">Level</button>
                <div class="absolute left-0 mt-1 w-48 bg-gray-800 rounded-md shadow-lg py-1 z-20 hidden">
                    <a href="#" id="new-level" class="block px-4 py-2 text-sm hover:bg-gray-700">New Level</a>
                    <a href="#" id="open-level" class="block px-4 py-2 text-sm hover:bg-gray-700">Open Level...</a>
                    <a href="#" id="save-level" class="block px-4 py-2 text-sm hover:bg-gray-700">Save Level</a>
                    <a href="#" id="save-level-as" class="block px-4 py-2 text-sm hover:bg-gray-700">Save Level As...</a>
                </div>
            </div>
            <div class="relative group" id="menu-settings">
                <button class="px-3 py-1 rounded hover:bg-gray-700 transition">Settings</button>
                <div class="absolute left-0 mt-1 w-48 bg-gray-800 rounded-md shadow-lg py-1 z-20 hidden">
                    <a href="#" id="assets-path" class="block px-4 py-2 text-sm hover:bg-gray-700">Assets Path...</a>
                </div>
            </div>
        </nav>
    </header>

    <!-- Основной контейнер с рабочими зонами -->
    <div class="flex flex-grow min-h-0">
        <!-- 2. Main Frame (основная рабочая зона) -->
        <main id="main-panel" class="flex-grow flex flex-col bg-gray-700 p-1">
            <canvas id="main-canvas"></canvas>
        </main>

        <!-- Разделитель для изменения ширины правой панели -->
        <div id="resizer-x" class="resizer"></div>

        <!-- 4. Панель Details (справа) -->
        <aside id="right-panel" class="w-80 bg-gray-900 flex flex-col flex-shrink-0">
            <div class="flex border-b border-gray-700 flex-shrink-0">
                <button data-tab="details" class="tab-right flex-1 p-2 text-sm font-medium active">Details</button>
                <button data-tab="level" class="tab-right flex-1 p-2 text-sm font-medium">Level</button>
                <button data-tab="outliner" class="tab-right flex-1 p-2 text-sm font-medium">Outliner</button>
            </div>
            <div class="flex-grow overflow-y-auto">
                <div id="details-content-panel" class="p-4 tab-content-right">
                     <p class="text-gray-400">Select an object to see its properties.</p>
                </div>
                 <div id="level-content-panel" class="p-4 tab-content-right hidden">
                    <h3 class="text-md font-bold mb-2">Level Stats</h3>
                    <div id="level-stats-content"></div>
                </div>
                <div id="outliner-content-panel" class="p-4 tab-content-right hidden">
                     <!-- Outliner content here -->
                </div>
            </div>
        </aside>
    </div>

    <!-- Разделитель для изменения высоты нижней панели -->
    <div id="resizer-y" class="resizer-y"></div>

    <!-- 3. Assets Drawer (панель с ассетами) -->
    <footer id="assets-panel" class="h-64 bg-gray-900 flex-shrink-0 flex flex-col relative">
        <div id="asset-tabs-container" class="flex border-b border-gray-700">
            <!-- Табы будут генерироваться динамически -->
        </div>
        <div id="asset-previews-container" class="flex-grow p-4 overflow-auto">
            <!-- Контейнер для превью ассетов будет генерироваться динамически -->
        </div>
    </footer>

    <!-- Логика приложения -->
    <script type="module">
        // --- DOM элементы ---
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const assetTabsContainer = document.getElementById('asset-tabs-container');
        const assetPreviewsContainer = document.getElementById('asset-previews-container');
        const assetsPanel = document.getElementById('assets-panel');
        // Элементы меню
        const menuLevel = document.getElementById('menu-level');
        const menuSettings = document.getElementById('menu-settings');
        const newLevelBtn = document.getElementById('new-level');
        const openLevelBtn = document.getElementById('open-level');
        const saveLevelBtn = document.getElementById('save-level');
        const saveLevelAsBtn = document.getElementById('save-level-as');
        // Правая панель
        const rightPanelTabs = document.querySelectorAll('.tab-right');
        const rightPanelContents = document.querySelectorAll('.tab-content-right');
        const detailsContentPanel = document.getElementById('details-content-panel');
        const levelStatsContent = document.getElementById('level-stats-content');
        const outlinerContentPanel = document.getElementById('outliner-content-panel');

        // --- Библиотека Ассетов ---
        const assetLibrary = {
            'Tiles': [
                { id: 'tile_grass', name: 'Grass', type: 'tile', width: 32, height: 32, color: '#2ecc71', imgSrc: 'https://placehold.co/80x80/2ecc71/ffffff?text=Grass' },
                { id: 'tile_dirt', name: 'Dirt', type: 'tile', width: 32, height: 32, color: '#95a5a6', imgSrc: 'https://placehold.co/80x80/95a5a6/ffffff?text=Dirt' },
            ],
            'Enemies': [
                { id: 'enemy_slime', name: 'Slime', type: 'enemy', width: 32, height: 32, color: '#e74c3c', health: 10, imgSrc: 'https://placehold.co/80x80/e74c3c/ffffff?text=Slime' },
            ],
            'Items': [
                 { id: 'item_coin', name: 'Coin', type: 'item', width: 16, height: 16, color: '#f1c40f', value: 10, imgSrc: 'https://placehold.co/80x80/f1c40f/ffffff?text=Coin' },
            ],
            'Prefabs': [],
        };
        const imageCache = {};

        // --- Состояние редактора ---
        let state = {};
        
        function getInitialState() {
             return {
                isDirty: false,
                camera: { x: 0, y: 0, zoom: 1 },
                mouse: {
                    x: 0, y: 0, worldX: 0, worldY: 0,
                    isLeftDown: false, isRightDown: false, isDragging: false,
                    dragStartX: 0, dragStartY: 0, lastX: 0, lastY: 0,
                    isDraggingAsset: false, isMarqueeSelecting: false, marqueeRect: null,
                    isAssetMarqueeSelecting: false, isPlacingObjects: false,
                    placingObjects: [], placingOffsets: [],
                    draggingGroupId: null, // For creating prefabs
                },
                history: { undoStack: [], redoStack: [], maxSize: 50 },
                nextObjectId: 1,
                levelObjects: [],
                selectedObjects: new Set(),
                assets: {
                    activeTabs: new Set(['Tiles']),
                    selected: new Set(),
                },
                outliner: {
                    collapsedTypes: new Set(),
                },
                currentLevelFileName: null,
             };
        }

        function resetState() {
            state = getInitialState();
            state.levelObjects.push(
                 { id: state.nextObjectId++, name: 'Player Start', x: 50, y: 50, width: 32, height: 32, color: 'lightblue', type: 'player_start', imgSrc: null },
                 { id: state.nextObjectId++, name: 'Enemy Spawn', x: 150, y: 100, width: 32, height: 32, color: 'lightgreen', type: 'enemy_spawn', imgSrc: null }
            );
            saveStateForUndo(true);
            updateAllPanels();
            draw();
        }


        // --- Управление историей (Undo/Redo) ---
        function saveStateForUndo(isInitial = false) {
            const currentState = JSON.stringify(state.levelObjects);
            const lastState = state.history.undoStack[state.history.undoStack.length - 1];
            if (isInitial || currentState !== lastState) {
                state.history.undoStack.push(currentState);
                if (state.history.undoStack.length > state.history.maxSize) state.history.undoStack.shift();
                state.history.redoStack = [];
                state.isDirty = !isInitial;
            }
        }
        function undo() {
            if (state.history.undoStack.length > 1) {
                state.history.redoStack.push(state.history.undoStack.pop());
                state.levelObjects = JSON.parse(state.history.undoStack[state.history.undoStack.length - 1]);
                state.selectedObjects.clear();
                updateAllPanels(); draw();
                state.isDirty = true;
            }
        }
        function redo() {
            if (state.history.redoStack.length > 0) {
                const nextStateJSON = state.history.redoStack.pop();
                state.history.undoStack.push(nextStateJSON);
                state.levelObjects = JSON.parse(nextStateJSON);
                state.selectedObjects.clear();
                updateAllPanels(); draw();
                state.isDirty = true;
            }
        }
        
        // --- Вспомогательные функции ---
        const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        
        function screenToWorld(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            return { x: (screenX - rect.left) / state.camera.zoom + state.camera.x, y: (screenY - rect.top) / state.camera.zoom + state.camera.y };
        }
        
        function isPointInRect(px, py, obj) {
             const bounds = getObjectWorldBounds(obj);
             return px >= bounds.minX && px <= bounds.maxX && py >= bounds.minY && py <= bounds.maxY;
        }

        function preloadAssets() { Object.values(assetLibrary).flat().forEach(asset => { if (asset.imgSrc) { const img = new Image(); img.src = asset.imgSrc; imageCache[asset.imgSrc] = img; img.onload = () => draw(); } }); }
        
        // --- Логика Иерархии и Групп ---
        function findObjectById(id, collection = state.levelObjects) {
            for (const obj of collection) {
                if (obj.id === id) return obj;
                if (obj.type === 'group') {
                    const found = findObjectById(id, obj.children);
                    if (found) return found;
                }
            }
            return null;
        }
        
        function getObjectWorldBounds(obj) {
            const bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            
            function calculateBounds(currentObj, parentX = 0, parentY = 0) {
                const absoluteX = currentObj.x + parentX;
                const absoluteY = currentObj.y + parentY;

                if (currentObj.type === 'group') {
                    if (currentObj.children.length === 0) { // Handle empty group
                        bounds.minX = Math.min(bounds.minX, absoluteX);
                        bounds.minY = Math.min(bounds.minY, absoluteY);
                        bounds.maxX = Math.max(bounds.maxX, absoluteX);
                        bounds.maxY = Math.max(bounds.maxY, absoluteY);
                    } else {
                        currentObj.children.forEach(child => calculateBounds(child, absoluteX, absoluteY));
                    }
                } else {
                    bounds.minX = Math.min(bounds.minX, absoluteX);
                    bounds.minY = Math.min(bounds.minY, absoluteY);
                    bounds.maxX = Math.max(bounds.maxX, absoluteX + currentObj.width);
                    bounds.maxY = Math.max(bounds.maxY, absoluteY + currentObj.height);
                }
            }
            
            calculateBounds(obj);
            return bounds;
        }

        function* walk(collection) {
            for (const obj of collection) {
                yield obj;
                if (obj.type === 'group') {
                    yield* walk(obj.children);
                }
            }
        }
        
        function getFlattenedObjects(collection = state.levelObjects) {
            return [...walk(collection)];
        }
        
        // --- Логика отрисовки ---
        function drawGrid() {
            ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1 / state.camera.zoom; const gridSize = 32; const scaledGridSize = gridSize; const startX = state.camera.x - (state.camera.x % gridSize); const startY = state.camera.y - (state.camera.y % gridSize); const endX = state.camera.x + canvas.width / state.camera.zoom; const endY = state.camera.y + canvas.height / state.camera.zoom;
            for (let x = startX; x < endX; x += scaledGridSize) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke(); }
            for (let y = startY; y < endY; y += scaledGridSize) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke(); }
            ctx.restore();
        }
        function drawObjects(objects, parentX = 0, parentY = 0) {
            objects.forEach(obj => {
                const absX = obj.x + parentX;
                const absY = obj.y + parentY;
                if (obj.type === 'group') {
                    drawObjects(obj.children, absX, absY);
                } else {
                    const img = obj.imgSrc ? imageCache[obj.imgSrc] : null;
                    if (img && img.complete && img.naturalHeight !== 0) ctx.drawImage(img, absX, absY, obj.width, obj.height);
                    else { ctx.fillStyle = obj.color || '#cccccc'; ctx.fillRect(absX, absY, obj.width, obj.height); }
                }
            });
        }
        function drawSelection() {
             getFlattenedObjects().forEach(obj => {
                if (state.selectedObjects.has(obj.id)) {
                    const bounds = getObjectWorldBounds(obj);
                     if (obj.type === 'group') {
                        ctx.strokeStyle = '#3B82F6'; ctx.lineWidth = 4 / state.camera.zoom;
                        ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                    } else {
                        ctx.strokeStyle = '#3B82F6'; ctx.lineWidth = 2 / state.camera.zoom;
                        ctx.strokeRect(bounds.minX, bounds.minY, obj.width, obj.height);
                    }
                }
            });
        }
        function drawPlacingObjects() {
            if (!state.mouse.isPlacingObjects) return;
             ctx.save();
             ctx.globalAlpha = 0.7;
             drawObjects(state.mouse.placingObjects, 0, 0);
             ctx.restore();
        }
        function drawMarquee() { if (!state.mouse.marqueeRect) return; const r = state.mouse.marqueeRect; ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; ctx.fillRect(r.x, r.y, r.width, r.height); ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'; ctx.lineWidth = 1 / state.camera.zoom; ctx.strokeRect(r.x, r.y, r.width, r.height); }
        function draw() {
            ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#4B5563'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.scale(state.camera.zoom, state.camera.zoom); ctx.translate(-state.camera.x, -state.camera.y);
            drawGrid();
            drawObjects(state.levelObjects);
            drawSelection();
            drawPlacingObjects();
            drawMarquee();
            ctx.restore();
        }

        // --- Управление Панелями ---
        function updateAllPanels() { updateDetailsPanel(); updateLevelDetailsPanel(); updateOutliner(); }
        
        function updateDetailsPanel() {
            detailsContentPanel.innerHTML = ''; 
            const selectedObjects = Array.from(state.selectedObjects).map(id => findObjectById(id)).filter(Boolean);

            if (selectedObjects.length === 0) {
                detailsContentPanel.innerHTML = '<p class="text-gray-400">Select an object.</p>';
                return;
            }

            if (selectedObjects.length === 1 && selectedObjects[0].type === 'group') {
                const group = selectedObjects[0];
                const childAssets = getFlattenedObjects(group.children).filter(o => o.type !== 'group').length;
                const childGroups = getFlattenedObjects(group.children).filter(o => o.type === 'group').length;

                detailsContentPanel.innerHTML = `
                    <div class="mb-3">
                        <label class="block text-sm font-medium text-gray-300">Group Name</label>
                        <input id="group-name-input" type="text" value="${group.name}" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    <div class="text-sm text-gray-400">
                        <p>Assets: ${childAssets}</p>
                        <p>Groups: ${childGroups}</p>
                    </div>`;
                document.getElementById('group-name-input').addEventListener('change', (e) => {
                    saveStateForUndo();
                    group.name = e.target.value;
                    updateOutliner();
                });
            } else {
                 const commonProps = ['x', 'y', 'width', 'height', 'name'];
                 commonProps.forEach(prop => {
                    const firstValue = selectedObjects[0][prop];
                    const allSame = selectedObjects.every(item => item[prop] === firstValue);
                    let displayValue = allSame ? (typeof firstValue === 'number' ? firstValue.toFixed(1) : firstValue) : '';
                    
                    const propContainer = document.createElement('div');
                    propContainer.className = 'mb-3';
                    propContainer.innerHTML = `<label class="block text-sm font-medium text-gray-300 capitalize">${prop}</label>
                        <input type="text" value="${displayValue}" placeholder="${allSame ? '' : 'multiple values'}" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">`;
                    
                    propContainer.querySelector('input').addEventListener('change', e => {
                        saveStateForUndo();
                        let newValue = e.target.value;
                        if (!isNaN(parseFloat(newValue)) && typeof firstValue === 'number') { newValue = parseFloat(newValue); }
                        selectedObjects.forEach(obj => obj[prop] = newValue);
                        draw();
                    });
                    detailsContentPanel.appendChild(propContainer);
                });
            }
        }
        
        function updateLevelDetailsPanel() {
            const allObjects = getFlattenedObjects();
            const objectCount = allObjects.filter(o => o.type !== 'group').length;
            const groupCount = allObjects.filter(o => o.type === 'group').length;
            levelStatsContent.innerHTML = `
                <p class="text-sm">Total Objects: ${objectCount}</p>
                <p class="text-sm">Total Groups: ${groupCount}</p>
            `;
        }
        
        function updateOutliner() {
            outlinerContentPanel.innerHTML = '';
            
            const groupedByType = getFlattenedObjects(state.levelObjects).reduce((acc, obj) => {
                const type = obj.type === 'group' ? 'Groups' : obj.type || 'Untyped';
                if (!acc[type]) acc[type] = [];
                acc[type].push(obj);
                return acc;
            }, {});

            const renderNode = (obj, depth = 0, container) => {
                const item = document.createElement('div');
                item.className = 'outliner-item';
                item.style.paddingLeft = `${5 + depth * 15}px`;
                item.textContent = obj.name || `[${obj.type}]`;
                item.dataset.id = obj.id;
                if (state.selectedObjects.has(obj.id)) item.classList.add('selected');
                
                item.addEventListener('click', e => {
                    if (e.shiftKey) state.selectedObjects.add(obj.id);
                    else { state.selectedObjects.clear(); state.selectedObjects.add(obj.id); }
                    updateAllPanels(); draw();
                });
                
                container.appendChild(item);
                if (obj.type === 'group') {
                    obj.children.forEach(child => renderNode(child, depth + 1, container));
                }
            };
            
            Object.keys(groupedByType).sort().forEach(type => {
                const header = document.createElement('h4');
                header.className = 'outliner-group-header mt-2';
                const isCollapsed = state.outliner.collapsedTypes.has(type);
                if (isCollapsed) header.classList.add('collapsed');
                header.textContent = type;
                
                const itemsContainer = document.createElement('div');
                if (isCollapsed) itemsContainer.classList.add('hidden');

                header.addEventListener('dblclick', () => {
                    if (state.outliner.collapsedTypes.has(type)) {
                        state.outliner.collapsedTypes.delete(type);
                    } else {
                        state.outliner.collapsedTypes.add(type);
                    }
                    updateOutliner();
                });
                
                outlinerContentPanel.appendChild(header);
                outlinerContentPanel.appendChild(itemsContainer);

                if (type === 'Groups') {
                    state.levelObjects.filter(obj => obj.type === 'group').forEach(group => renderNode(group, 0, itemsContainer));
                } else {
                    groupedByType[type].forEach(obj => renderNode(obj, 0, itemsContainer));
                }
            });
        }
        
        function renderAssetPanel() {
            assetTabsContainer.innerHTML = '';
            Object.keys(assetLibrary).forEach(tabName => {
                const tabButton = document.createElement('button');
                tabButton.className = `tab px-4 py-2 text-sm font-medium border-b-2 border-transparent hover:bg-gray-700 ${state.assets.activeTabs.has(tabName) ? 'active' : ''}`;
                tabButton.innerText = tabName;
                tabButton.addEventListener('click', (e) => {
                    if (e.shiftKey) { if (state.assets.activeTabs.has(tabName)) { if (state.assets.activeTabs.size > 1) state.assets.activeTabs.delete(tabName); } else { state.assets.activeTabs.add(tabName); } }
                    else { state.assets.activeTabs.clear(); state.assets.activeTabs.add(tabName); }
                    state.assets.selected.clear(); renderAssetPanel();
                });
                assetTabsContainer.appendChild(tabButton);
            });

            assetPreviewsContainer.innerHTML = '';
            const assetsToShow = Array.from(state.assets.activeTabs).flatMap(tabName => assetLibrary[tabName] || []);
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-12 gap-4';
            assetsToShow.forEach(asset => {
                const thumb = document.createElement('div');
                thumb.className = `asset-thumbnail w-24 h-24 bg-gray-700 rounded-md flex items-center justify-center cursor-pointer p-1 ${state.assets.selected.has(asset.id) ? 'selected' : ''}`;
                thumb.dataset.assetId = asset.id;
                thumb.draggable = true;
                const img = document.createElement('img'); img.src = asset.imgSrc; img.alt = asset.name; img.draggable = false; img.onerror = () => { img.style.display = 'none'; }; thumb.appendChild(img);
                
                thumb.addEventListener('click', (e) => {
                    const assetId = thumb.dataset.assetId;
                    if (e.shiftKey) { if (state.assets.selected.has(assetId)) state.assets.selected.delete(assetId); else state.assets.selected.add(assetId); }
                    else { state.assets.selected.clear(); state.assets.selected.add(assetId); }
                    renderAssetPanel();
                });
                thumb.addEventListener('dragstart', (e) => {
                    state.mouse.isDraggingAsset = true;
                    let draggedAssetIds = state.assets.selected.has(asset.id) ? Array.from(state.assets.selected) : [asset.id];
                    e.dataTransfer.setData('application/json', JSON.stringify(draggedAssetIds));
                    e.dataTransfer.effectAllowed = 'copy';
                });
                grid.appendChild(thumb);
            });
            assetPreviewsContainer.appendChild(grid);
        }
        
        // --- Логика Сохранения/Загрузки ---
        function packageLevelData() { return { meta: { savedAt: new Date().toISOString() }, camera: state.camera, objects: state.levelObjects, nextId: state.nextObjectId, prefabs: assetLibrary.Prefabs }; }
        function loadLevelData(levelData) {
            if (!levelData || !Array.isArray(levelData.objects)) { alert("Error: Invalid level file format."); return; }
            state = getInitialState();
            state.levelObjects = levelData.objects;
            state.camera = levelData.camera || { x: 0, y: 0, zoom: 1 };
            state.nextObjectId = levelData.nextId || getFlattenedObjects().reduce((max, obj) => Math.max(max, obj.id || 0), 0) + 1;
            assetLibrary.Prefabs = levelData.prefabs || [];
            saveStateForUndo(true);
            state.isDirty = false;
            updateAllPanels(); renderAssetPanel(); draw();
        }
        function handleSaveLevelAs() {
            const fileName = prompt("Enter file name:", state.currentLevelFileName || "level-1.json");
            if (!fileName) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify(packageLevelData(), null, 2)], { type: "application/json" }));
            a.download = fileName; a.click(); URL.revokeObjectURL(a.href);
            state.currentLevelFileName = fileName; state.isDirty = false;
        }
        function handleOpenLevel() {
            if (state.isDirty && !confirm("You have unsaved changes. Are you sure you want to open a new level?")) return;
            const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
            input.onchange = e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { loadLevelData(JSON.parse(event.target.result)); state.currentLevelFileName = file.name; } catch (err) { alert("Error: Could not read or parse the level file."); } }; reader.readAsText(file); };
            input.click();
        }
        function handleNewLevel() {
            if (state.isDirty && !confirm("You have unsaved changes. Are you sure you want to create a new level?")) return;
            resetState();
        }
        
        // --- Управление камерой и мышью ---
        function getSelectionBounds(collection) {
            if (collection.length === 0) return null;
            const bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            collection.forEach(obj => {
                const objBounds = getObjectWorldBounds(obj);
                bounds.minX = Math.min(bounds.minX, objBounds.minX);
                bounds.minY = Math.min(bounds.minY, objBounds.minY);
                bounds.maxX = Math.max(bounds.maxX, objBounds.maxX);
                bounds.maxY = Math.max(bounds.maxY, objBounds.maxY);
            });
            return bounds;
        }
        
        function focusOnBounds(bounds) {
             if (!bounds || bounds.minX === Infinity) return;
             const boundsWidth = bounds.maxX - bounds.minX;
             const boundsHeight = bounds.maxY - bounds.minY;
             const padding = 50;
             const zoomX = canvas.width / (boundsWidth + padding * 2);
             const zoomY = canvas.height / (boundsHeight + padding * 2);
             state.camera.zoom = Math.max(0.1, Math.min(10, Math.min(zoomX, zoomY)));
             const centerX = bounds.minX + boundsWidth / 2;
             const centerY = bounds.minY + boundsHeight / 2;
             state.camera.x = centerX - (canvas.width / 2) / state.camera.zoom;
             state.camera.y = centerY - (canvas.height / 2) / state.camera.zoom;
             draw();
        }
        
        // --- Инициализация ---
        function init() {
            resetState();
            resizeCanvas();
            preloadAssets();
            updateAllPanels();
            renderAssetPanel();

            // --- Menu Logic ---
            [menuLevel, menuSettings].forEach(menu => {
                const button = menu.querySelector('button');
                const dropdown = menu.querySelector('div');
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = dropdown.classList.contains('hidden');
                    // Close all menus first
                    document.querySelectorAll('#menu-level > div, #menu-settings > div').forEach(d => d.classList.add('hidden'));
                    if (isHidden) {
                        dropdown.classList.remove('hidden');
                    }
                });
            });
            window.addEventListener('click', () => {
                 document.querySelectorAll('#menu-level > div, #menu-settings > div').forEach(d => d.classList.add('hidden'));
            });


            rightPanelTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    rightPanelTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    const tabName = tab.dataset.tab;
                    rightPanelContents.forEach(content => {
                        content.classList.toggle('hidden', content.id !== `${tabName}-content-panel`);
                    });
                });
            });
            
            // --- Event Listeners ---
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('resize', resizeCanvas);
            newLevelBtn.addEventListener('click', handleNewLevel);
            openLevelBtn.addEventListener('click', handleOpenLevel);
            saveLevelBtn.addEventListener('click', handleSaveLevelAs); // Save should work like Save As
            saveLevelAsBtn.addEventListener('click', handleSaveLevelAs);

             window.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT') return;
                
                if (e.key === 'Delete' || e.key.toLowerCase() === 'x') {
                    if (state.selectedObjects.size > 0) {
                        saveStateForUndo();
                        const idsToDelete = new Set(state.selectedObjects);
                        function filterRecursive(collection) {
                            return collection.filter(obj => !idsToDelete.has(obj.id)).map(obj => {
                                if (obj.type === 'group') obj.children = filterRecursive(obj.children);
                                return obj;
                            });
                        }
                        state.levelObjects = filterRecursive(state.levelObjects);
                        state.selectedObjects.clear();
                        updateAllPanels(); draw();
                    }
                } else if (e.shiftKey && e.key.toLowerCase() === 'd') {
                    e.preventDefault();
                    if (state.selectedObjects.size > 0 && !state.mouse.isPlacingObjects) {
                        const selected = Array.from(state.selectedObjects).map(id => findObjectById(id)).filter(Boolean);
                        state.mouse.isPlacingObjects = true;
                        state.mouse.placingObjects = deepClone(selected);
                        const worldPos = screenToWorld(e.clientX, e.clientY);
                        const bounds = getSelectionBounds(selected);
                        const centerX = bounds.minX + (bounds.maxX - bounds.minX) / 2;
                        const centerY = bounds.minY + (bounds.maxY - bounds.minY) / 2;
                        
                        const offsetX = worldPos.x - centerX;
                        const offsetY = worldPos.y - centerY;

                        state.mouse.placingObjects.forEach(obj => {
                           obj.x += offsetX;
                           obj.y += offsetY;
                        });

                        draw();
                    }
                } else if (e.key.toLowerCase() === 'f') {
                    const selection = Array.from(state.selectedObjects).map(id => findObjectById(id)).filter(Boolean);
                    focusOnBounds(getSelectionBounds(selection));
                } else if (e.key.toLowerCase() === 'a') {
                    focusOnBounds(getSelectionBounds(state.levelObjects));
                } else if (e.shiftKey && e.key.toLowerCase() === 'g') {
                    e.preventDefault();
                    if (state.selectedObjects.size > 1) {
                         saveStateForUndo();
                         // Find only top-level selected objects to form the new group
                         const selectedTopLevel = Array.from(state.selectedObjects)
                            .map(id => findObjectById(id))
                            .filter(obj => obj && state.levelObjects.some(topObj => topObj.id === obj.id));

                         if (selectedTopLevel.length > 1) {
                             const newGroup = { id: state.nextObjectId++, name: "New Group", type: 'group', x: 0, y: 0, children: deepClone(selectedTopLevel) };
                             const bounds = getSelectionBounds(selectedTopLevel);
                             newGroup.x = bounds.minX;
                             newGroup.y = bounds.minY;
                             newGroup.children.forEach(c => { c.x -= newGroup.x; c.y -= newGroup.y; });
                             
                             state.levelObjects = state.levelObjects.filter(obj => !selectedTopLevel.some(sel => sel.id === obj.id));
                             state.levelObjects.push(newGroup);
                             state.selectedObjects.clear();
                             state.selectedObjects.add(newGroup.id);
                             updateAllPanels(); draw();
                         }
                    }
                } else if (e.ctrlKey || e.metaKey) {
                    if (e.key.toLowerCase() === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
                    if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
                }
            });

            canvas.addEventListener('mousemove', e => {
                 const worldPos = screenToWorld(e.clientX, e.clientY);
                 state.mouse.worldX = worldPos.x;
                 state.mouse.worldY = worldPos.y;

                 if (state.mouse.isPlacingObjects) {
                    const bounds = getSelectionBounds(state.mouse.placingObjects);
                    const dx = worldPos.x - (bounds.minX + (bounds.maxX - bounds.minX) / 2);
                    const dy = worldPos.y - (bounds.minY + (bounds.maxY - bounds.minY) / 2);
                    state.mouse.placingObjects.forEach(obj => { obj.x += dx; obj.y += dy; });
                    draw();
                    return;
                 }
                 if (state.mouse.isRightDown) {
                    const dx = e.clientX - state.mouse.lastX; const dy = e.clientY - state.mouse.lastY;
                    state.camera.x -= dx / state.camera.zoom; state.camera.y -= dy / state.camera.zoom;
                    state.mouse.lastX = e.clientX; state.mouse.lastY = e.clientY;
                    draw();
                } else if (state.mouse.isLeftDown && state.mouse.isDragging && state.selectedObjects.size > 0) {
                    const dx = worldPos.x - state.mouse.dragStartX; const dy = worldPos.y - state.mouse.dragStartY;
                    state.selectedObjects.forEach(id => { 
                        const obj = findObjectById(id); 
                        if (obj && state.levelObjects.some(topObj => topObj.id === obj.id)) {
                           obj.x += dx; obj.y += dy; 
                        }
                    });
                    state.mouse.dragStartX = worldPos.x; state.mouse.dragStartY = worldPos.y;
                    updateDetailsPanel(); draw();
                } else if (state.mouse.isMarqueeSelecting) {
                    state.mouse.marqueeRect.width = worldPos.x - state.mouse.marqueeRect.x;
                    state.mouse.marqueeRect.height = worldPos.y - state.mouse.marqueeRect.y;
                    draw();
                }

                // Handle visual feedback for dropping group on assets panel
                if(state.mouse.draggingGroupId) {
                    const rect = assetsPanel.getBoundingClientRect();
                    if(e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        assetsPanel.classList.add('drop-target');
                    } else {
                        assetsPanel.classList.remove('drop-target');
                    }
                }
            });
            
            canvas.addEventListener('mousedown', e => {
                 if (state.mouse.isPlacingObjects) {
                     saveStateForUndo();
                     const newIds = new Set();
                     function assignNewIds(collection) {
                         collection.forEach(obj => {
                            obj.id = state.nextObjectId++;
                            newIds.add(obj.id);
                            if(obj.type === 'group') assignNewIds(obj.children);
                         });
                     }
                     assignNewIds(state.mouse.placingObjects);
                     state.levelObjects.push(...state.mouse.placingObjects);
                     state.mouse.isPlacingObjects = false;
                     state.mouse.placingObjects = [];
                     state.selectedObjects = newIds;
                     updateAllPanels();
                     draw();
                     return;
                 }
                const worldPos = screenToWorld(e.clientX, e.clientY);
                if (e.button === 2) { state.mouse.isRightDown = true; state.mouse.lastX = e.clientX; state.mouse.lastY = e.clientY; canvas.style.cursor = 'grabbing'; return; }
                if (e.button === 0) {
                    state.mouse.isLeftDown = true;
                    let objectClicked = null;
                    const flatObjects = getFlattenedObjects().reverse(); // check top objects first
                    for (const obj of flatObjects) {
                        if (isPointInRect(worldPos.x, worldPos.y, obj)) { objectClicked = obj; break; }
                    }

                    if (objectClicked) {
                        const isSelected = state.selectedObjects.has(objectClicked.id);
                        if (!e.shiftKey) { if (!isSelected) { state.selectedObjects.clear(); state.selectedObjects.add(objectClicked.id); } } 
                        else { if (isSelected) state.selectedObjects.delete(objectClicked.id); else state.selectedObjects.add(objectClicked.id); }
                        state.mouse.isDragging = true;
                        state.mouse.dragStartX = worldPos.x; state.mouse.dragStartY = worldPos.y;

                        // Check if we are dragging a selected group
                        if (objectClicked.type === 'group' && state.selectedObjects.has(objectClicked.id)) {
                           state.mouse.draggingGroupId = objectClicked.id;
                        }

                    } else {
                        if (!e.shiftKey) state.selectedObjects.clear();
                        state.mouse.isMarqueeSelecting = true;
                        state.mouse.marqueeRect = { x: worldPos.x, y: worldPos.y, width: 0, height: 0 };
                    }
                    updateAllPanels(); draw();
                }
            });

            window.addEventListener('mouseup', e => { // Listen on window to catch mouseup outside canvas
                if (state.mouse.draggingGroupId) {
                    assetsPanel.classList.remove('drop-target');
                    const rect = assetsPanel.getBoundingClientRect();
                    if(e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        const groupToSave = findObjectById(state.mouse.draggingGroupId);
                        if (groupToSave) {
                             const prefabName = prompt("Enter prefab name:", groupToSave.name);
                             if (prefabName) {
                                 const prefab = deepClone(groupToSave);
                                 prefab.id = `prefab_${Date.now()}`;
                                 prefab.name = prefabName;
                                 prefab.type = 'prefab';
                                 // Reset child positions relative to group origin
                                 const bounds = getSelectionBounds(prefab.children);
                                 if (bounds.minX !== Infinity) {
                                    prefab.children.forEach(c => { c.x -= bounds.minX; c.y -= bounds.minY; });
                                 }
                                 assetLibrary.Prefabs.push(prefab);
                                 state.assets.activeTabs.clear();
                                 state.assets.activeTabs.add('Prefabs');
                                 renderAssetPanel();
                             }
                        }
                    }
                    state.mouse.draggingGroupId = null;
                }

                if (e.button === 2) { state.mouse.isRightDown = false; canvas.style.cursor = 'default'; }
                if (e.button === 0) {
                    if(state.mouse.isDragging && state.selectedObjects.size > 0) saveStateForUndo();
                    state.mouse.isLeftDown = false; state.mouse.isDragging = false;
                    if (state.mouse.isMarqueeSelecting) {
                        state.mouse.isMarqueeSelecting = false;
                        const marquee = state.mouse.marqueeRect;
                        const r = { x: marquee.width < 0 ? marquee.x + marquee.width : marquee.x, y: marquee.height < 0 ? marquee.y + marquee.height : marquee.y, width: Math.abs(marquee.width), height: Math.abs(marquee.height) };
                        getFlattenedObjects().forEach(obj => {
                             const objBounds = getObjectWorldBounds(obj);
                             if (r.x < objBounds.maxX && r.x + r.width > objBounds.minX && r.y < objBounds.maxY && r.y + r.height > objBounds.minY) {
                                state.selectedObjects.add(obj.id);
                             }
                        });
                        state.mouse.marqueeRect = null;
                        updateAllPanels(); draw();
                    }
                }
            });

            canvas.addEventListener('wheel', e => {
                 e.preventDefault(); const zoomIntensity = 0.1; const direction = e.deltaY < 0 ? 1 : -1;
                 const oldZoom = state.camera.zoom; const newZoom = Math.max(0.1, Math.min(10, oldZoom * (1 + direction * zoomIntensity)));
                 const mouseWorldPosBeforeZoom = screenToWorld(e.clientX, e.clientY);
                 state.camera.zoom = newZoom;
                 const mouseWorldPosAfterZoom = screenToWorld(e.clientX, e.clientY);
                 state.camera.x += mouseWorldPosBeforeZoom.x - mouseWorldPosAfterZoom.x;
                 state.camera.y += mouseWorldPosBeforeZoom.y - mouseWorldPosAfterZoom.y;
                 draw();
            });
            
            canvas.addEventListener('dragover', e => {
                e.preventDefault(); // This is crucial for drop to work
                e.dataTransfer.dropEffect = 'copy';
            });

            canvas.addEventListener('drop', e => {
                 e.preventDefault();
                 if (!state.mouse.isDraggingAsset) return;
                 saveStateForUndo();
                 const droppedAssetIds = JSON.parse(e.dataTransfer.getData('application/json'));
                 const worldPos = screenToWorld(e.clientX, e.clientY);
                 const allAssets = Object.values(assetLibrary).flat();
                 
                 const newIds = new Set();
                 droppedAssetIds.forEach((assetId, index) => {
                     const assetProto = allAssets.find(a => a.id === assetId);
                     if (assetProto) {
                         const newObject = { ...deepClone(assetProto), id: state.nextObjectId++, x: worldPos.x, y: worldPos.y };
                         if(newObject.type === 'prefab') {
                             newObject.type = 'group'; // convert prefab to group instance
                             // Assign new IDs to all children of the prefab instance
                             getFlattenedObjects(newObject.children).forEach(child => child.id = state.nextObjectId++);
                         }
                         state.levelObjects.push(newObject);
                         newIds.add(newObject.id);
                     }
                 });
                 state.selectedObjects = newIds;
                 state.mouse.isDraggingAsset = false;
                 updateAllPanels(); draw();
            });
             
            // --- Asset Panel Marquee ---
            let assetMarqueeDiv = null;
            let assetMarqueeStart = {};
            assetPreviewsContainer.addEventListener('mousedown', e => {
                // Check if the click was on the background, not a thumbnail
                if (e.target.closest('.asset-thumbnail')) return;

                state.mouse.isAssetMarqueeSelecting = true;
                if (!e.shiftKey) state.assets.selected.clear();
                
                // Clear selection immediately if it's just a click, not a drag-select
                renderAssetPanel(); 

                assetMarqueeDiv = document.createElement('div');
                assetMarqueeDiv.id = 'asset-marquee';
                assetsPanel.appendChild(assetMarqueeDiv);
                const rect = assetPreviewsContainer.getBoundingClientRect();
                assetMarqueeStart = { x: e.clientX, y: e.clientY };
                assetMarqueeDiv.style.left = `${e.clientX - rect.left + assetPreviewsContainer.scrollLeft}px`;
                assetMarqueeDiv.style.top = `${e.clientY - rect.top + assetPreviewsContainer.scrollTop}px`;
                assetMarqueeDiv.style.width = '0px';
                assetMarqueeDiv.style.height = '0px';
            });
            window.addEventListener('mousemove', e => {
                if (!state.mouse.isAssetMarqueeSelecting) return;
                const rect = assetPreviewsContainer.getBoundingClientRect();
                const dx = e.clientX - assetMarqueeStart.x;
                const dy = e.clientY - assetMarqueeStart.y;
                assetMarqueeDiv.style.width = `${Math.abs(dx)}px`;
                assetMarqueeDiv.style.height = `${Math.abs(dy)}px`;
                assetMarqueeDiv.style.left = `${(dx < 0 ? e.clientX - rect.left : assetMarqueeStart.x - rect.left) + assetPreviewsContainer.scrollLeft}px`;
                assetMarqueeDiv.style.top = `${(dy < 0 ? e.clientY - rect.top : assetMarqueeStart.y - rect.top) + assetPreviewsContainer.scrollTop}px`;
            });
            window.addEventListener('mouseup', e => {
                if (!state.mouse.isAssetMarqueeSelecting) return;
                state.mouse.isAssetMarqueeSelecting = false;
                const marqueeRect = assetMarqueeDiv.getBoundingClientRect();
                document.querySelectorAll('.asset-thumbnail').forEach(thumb => {
                    const thumbRect = thumb.getBoundingClientRect();
                    // Check for intersection only if marquee has a size (not a simple click)
                    if (marqueeRect.width > 2 && marqueeRect.height > 2 &&
                        marqueeRect.left < thumbRect.right && marqueeRect.right > thumbRect.left && 
                        marqueeRect.top < thumbRect.bottom && marqueeRect.bottom > thumbRect.top) {
                        state.assets.selected.add(thumb.dataset.assetId);
                    }
                });
                assetsPanel.removeChild(assetMarqueeDiv);
                renderAssetPanel();
            });

        }
        
        init();
    </script>
</body>
</html>

