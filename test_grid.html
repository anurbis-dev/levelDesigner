<!DOCTYPE html>
<html>
<head>
    <title>Grid Test</title>
    <style>
        body { margin: 0; background: #1f2937; color: white; font-family: monospace; }
        canvas { border: 1px solid #374151; }
        .controls { padding: 10px; }
        input { margin: 5px; }
    </style>
</head>
<body>
    <div class="controls">
        <label>Grid Size: <input type="number" id="gridSize" value="32" min="8" max="128"></label>
        <label>Grid Color: <input type="color" id="gridColor" value="#ffffff"></label>
        <label>Grid Opacity: <input type="range" id="gridOpacity" value="0.1" min="0" max="1" step="0.05"></label>
        <label>Grid Thickness: <input type="number" id="gridThickness" value="1" min="0.1" max="5" step="0.1"></label>
        <label>Subdivisions: <input type="number" id="gridSubdivisions" value="4" min="1" max="10"></label>
        <label>Subdiv Color: <input type="color" id="gridSubdivColor" value="#666666"></label>
        <button onclick="updateGrid()">Update Grid</button>
        <button onclick="resetGrid()">Reset to Defaults</button>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Test grid settings
        let gridSettings = {
            size: 32,
            color: '#ffffff',
            opacity: 0.1,
            thickness: 1,
            subdivisions: 4,
            subdivColor: '#666666',
            subdivThickness: 0.5
        };

        const camera = { x: 0, y: 0, zoom: 1 };

        function updateGrid() {
            gridSettings.size = parseInt(document.getElementById('gridSize').value);
            gridSettings.color = document.getElementById('gridColor').value;
            gridSettings.opacity = parseFloat(document.getElementById('gridOpacity').value);
            gridSettings.thickness = parseFloat(document.getElementById('gridThickness').value);
            gridSettings.subdivisions = parseInt(document.getElementById('gridSubdivisions').value);
            gridSettings.subdivColor = document.getElementById('gridSubdivColor').value;

            console.log('Updated grid settings:', gridSettings);
            drawGrid();
        }

        function resetGrid() {
            document.getElementById('gridSize').value = 32;
            document.getElementById('gridColor').value = '#ffffff';
            document.getElementById('gridOpacity').value = 0.1;
            document.getElementById('gridThickness').value = 1;
            document.getElementById('gridSubdivisions').value = 4;
            document.getElementById('gridSubdivColor').value = '#666666';
            updateGrid();
        }

        function drawGrid() {
            ctx.save();
            ctx.fillStyle = '#4B5563';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridSize = gridSettings.size;
            const minGridSize = 5;
            if (gridSize * camera.zoom < minGridSize) {
                ctx.restore();
                return;
            }

            // Convert colors to rgba
            let gridColor = gridSettings.color;
            if (gridColor.startsWith('#')) {
                const r = parseInt(gridColor.slice(1, 3), 16);
                const g = parseInt(gridColor.slice(3, 5), 16);
                const b = parseInt(gridColor.slice(5, 7), 16);
                gridColor = `rgba(${r}, ${g}, ${b}, ${gridSettings.opacity})`;
            }

            let gridSubdivColor = gridSettings.subdivColor;
            if (gridSubdivColor.startsWith('#')) {
                const r = parseInt(gridSubdivColor.slice(1, 3), 16);
                const g = parseInt(gridSubdivColor.slice(3, 5), 16);
                const b = parseInt(gridSubdivColor.slice(5, 7), 16);
                gridSubdivColor = `rgba(${r}, ${g}, ${b}, ${gridSettings.opacity})`;
            }

            console.log('Drawing grid with:', {
                gridSize,
                gridColor,
                gridThickness: gridSettings.thickness,
                gridSubdivisions: gridSettings.subdivisions,
                gridSubdivColor,
                gridSubdivThickness: gridSettings.subdivThickness
            });

            // Draw main grid lines
            drawGridLines(gridSize, gridColor, gridSettings.thickness);

            // Draw subdivision lines
            if (gridSettings.subdivisions > 1) {
                const subdivSize = gridSize / gridSettings.subdivisions;
                drawGridLines(subdivSize, gridSubdivColor, gridSettings.subdivThickness);
            }

            ctx.restore();
        }

        function drawGridLines(gridSize, color, thickness) {
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness / camera.zoom;

            const startX = camera.x - (camera.x % gridSize);
            const startY = camera.y - (camera.y % gridSize);
            const endX = camera.x + canvas.width / camera.zoom;
            const endY = camera.y + canvas.height / camera.zoom;

            // Draw vertical lines
            for (let x = startX; x < endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = startY; y < endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
        }

        // Initial draw
        drawGrid();

        // Update on input changes
        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', updateGrid);
        });
    </script>
</body>
</html>
